{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GridStack = void 0;\n/*!\r\n * GridStack 7.2.3\r\n * https://gridstackjs.com/\r\n *\r\n * Copyright (c) 2021-2022 Alain Dumesny\r\n * see root license https://github.com/gridstack/gridstack.js/tree/master/LICENSE\r\n */\nconst gridstack_engine_1 = require(\"./gridstack-engine\");\nconst utils_1 = require(\"./utils\");\nconst types_1 = require(\"./types\");\n/*\r\n * and include D&D by default\r\n * TODO: while we could generate a gridstack-static.js at smaller size - saves about 31k (41k -> 72k)\r\n * I don't know how to generate the DD only code at the remaining 31k to delay load as code depends on Gridstack.ts\r\n * also it caused loading issues in prod - see https://github.com/gridstack/gridstack.js/issues/2039\r\n */\nconst dd_gridstack_1 = require(\"./dd-gridstack\");\nconst dd_touch_1 = require(\"./dd-touch\");\nconst dd_manager_1 = require(\"./dd-manager\");\n/** global instance */\nconst dd = new dd_gridstack_1.DDGridStack();\n// export all dependent file as well to make it easier for users to just import the main file\n__exportStar(require(\"./types\"), exports);\n__exportStar(require(\"./utils\"), exports);\n__exportStar(require(\"./gridstack-engine\"), exports);\n__exportStar(require(\"./dd-gridstack\"), exports);\n/**\r\n * Main gridstack class - you will need to call `GridStack.init()` first to initialize your grid.\r\n * Note: your grid elements MUST have the following classes for the CSS layout to work:\r\n * @example\r\n * <div class=\"grid-stack\">\r\n *   <div class=\"grid-stack-item\">\r\n *     <div class=\"grid-stack-item-content\">Item 1</div>\r\n *   </div>\r\n * </div>\r\n */\nclass GridStack {\n  /**\r\n   * Construct a grid item from the given element and options\r\n   * @param el\r\n   * @param opts\r\n   */\n  constructor(el) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _a, _b;\n    /** @internal */\n    this._gsEventHandler = {};\n    /** @internal extra row added when dragging at the bottom of the grid */\n    this._extraDragRow = 0;\n    this.el = el; // exposed HTML element to the user\n    opts = opts || {}; // handles null/undefined/0\n    if (!el.classList.contains('grid-stack')) {\n      this.el.classList.add('grid-stack');\n    }\n    // if row property exists, replace minRow and maxRow instead\n    if (opts.row) {\n      opts.minRow = opts.maxRow = opts.row;\n      delete opts.row;\n    }\n    let rowAttr = utils_1.Utils.toNumber(el.getAttribute('gs-row'));\n    // flag only valid in sub-grids (handled by parent, not here)\n    if (opts.column === 'auto') {\n      delete opts.column;\n    }\n    // 'minWidth' legacy support in 5.1\n    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n    let anyOpts = opts;\n    if (anyOpts.minWidth !== undefined) {\n      opts.oneColumnSize = opts.oneColumnSize || anyOpts.minWidth;\n      delete anyOpts.minWidth;\n    }\n    // save original setting so we can restore on save\n    if (opts.alwaysShowResizeHandle !== undefined) {\n      opts._alwaysShowResizeHandle = opts.alwaysShowResizeHandle;\n    }\n    // elements DOM attributes override any passed options (like CSS style) - merge the two together\n    let defaults = Object.assign(Object.assign({}, utils_1.Utils.cloneDeep(types_1.gridDefaults)), {\n      column: utils_1.Utils.toNumber(el.getAttribute('gs-column')) || types_1.gridDefaults.column,\n      minRow: rowAttr ? rowAttr : utils_1.Utils.toNumber(el.getAttribute('gs-min-row')) || types_1.gridDefaults.minRow,\n      maxRow: rowAttr ? rowAttr : utils_1.Utils.toNumber(el.getAttribute('gs-max-row')) || types_1.gridDefaults.maxRow,\n      staticGrid: utils_1.Utils.toBool(el.getAttribute('gs-static')) || types_1.gridDefaults.staticGrid,\n      draggable: {\n        handle: (opts.handleClass ? '.' + opts.handleClass : opts.handle ? opts.handle : '') || types_1.gridDefaults.draggable.handle\n      },\n      removableOptions: {\n        accept: opts.itemClass ? '.' + opts.itemClass : types_1.gridDefaults.removableOptions.accept\n      }\n    });\n    if (el.getAttribute('gs-animate')) {\n      // default to true, but if set to false use that instead\n      defaults.animate = utils_1.Utils.toBool(el.getAttribute('gs-animate'));\n    }\n    this.opts = utils_1.Utils.defaults(opts, defaults);\n    opts = null; // make sure we use this.opts instead\n    this._initMargin(); // part of settings defaults...\n    // Now check if we're loading into 1 column mode FIRST so we don't do un-necessary work (like cellHeight = width / 12 then go 1 column)\n    if (this.opts.column !== 1 && !this.opts.disableOneColumnMode && this._widthOrContainer() <= this.opts.oneColumnSize) {\n      this._prevColumn = this.getColumn();\n      this.opts.column = 1;\n    }\n    if (this.opts.rtl === 'auto') {\n      this.opts.rtl = el.style.direction === 'rtl';\n    }\n    if (this.opts.rtl) {\n      this.el.classList.add('grid-stack-rtl');\n    }\n    // check if we're been nested, and if so update our style and keep pointer around (used during save)\n    let parentGridItem = (_a = utils_1.Utils.closestUpByClass(this.el, types_1.gridDefaults.itemClass)) === null || _a === void 0 ? void 0 : _a.gridstackNode;\n    if (parentGridItem) {\n      parentGridItem.subGrid = this;\n      this.parentGridItem = parentGridItem;\n      this.el.classList.add('grid-stack-nested');\n      parentGridItem.el.classList.add('grid-stack-sub-grid');\n    }\n    this._isAutoCellHeight = this.opts.cellHeight === 'auto';\n    if (this._isAutoCellHeight || this.opts.cellHeight === 'initial') {\n      // make the cell content square initially (will use resize/column event to keep it square)\n      this.cellHeight(undefined, false);\n    } else {\n      // append unit if any are set\n      if (typeof this.opts.cellHeight == 'number' && this.opts.cellHeightUnit && this.opts.cellHeightUnit !== types_1.gridDefaults.cellHeightUnit) {\n        this.opts.cellHeight = this.opts.cellHeight + this.opts.cellHeightUnit;\n        delete this.opts.cellHeightUnit;\n      }\n      this.cellHeight(this.opts.cellHeight, false);\n    }\n    // see if we need to adjust auto-hide\n    if (this.opts.alwaysShowResizeHandle === 'mobile') {\n      this.opts.alwaysShowResizeHandle = dd_touch_1.isTouch;\n    }\n    this._styleSheetClass = 'grid-stack-instance-' + gridstack_engine_1.GridStackEngine._idSeq++;\n    this.el.classList.add(this._styleSheetClass);\n    this._setStaticClass();\n    let engineClass = this.opts.engineClass || GridStack.engineClass || gridstack_engine_1.GridStackEngine;\n    this.engine = new engineClass({\n      column: this.getColumn(),\n      float: this.opts.float,\n      maxRow: this.opts.maxRow,\n      onChange: cbNodes => {\n        let maxH = 0;\n        this.engine.nodes.forEach(n => {\n          maxH = Math.max(maxH, n.y + n.h);\n        });\n        cbNodes.forEach(n => {\n          let el = n.el;\n          if (!el) return;\n          if (n._removeDOM) {\n            if (el) el.remove();\n            delete n._removeDOM;\n          } else {\n            this._writePosAttr(el, n);\n          }\n        });\n        this._updateStyles(false, maxH); // false = don't recreate, just append if need be\n      }\n    });\n\n    if (this.opts.auto) {\n      this.batchUpdate(); // prevent in between re-layout #1535 TODO: this only set float=true, need to prevent collision check...\n      let elements = [];\n      let column = this.getColumn();\n      if (column === 1 && this._prevColumn) column = this._prevColumn; // do 12 column when reading into 1 column mode\n      this.getGridItems().forEach(el => {\n        let x = parseInt(el.getAttribute('gs-x'));\n        let y = parseInt(el.getAttribute('gs-y'));\n        elements.push({\n          el,\n          // if x,y are missing (autoPosition) add them to end of list - but keep their respective DOM order\n          i: (Number.isNaN(x) ? 1000 : x) + (Number.isNaN(y) ? 1000 : y) * column\n        });\n      });\n      elements.sort((a, b) => b.i - a.i).forEach(e => this._prepareElement(e.el)); // revert sort so lowest item wins\n      this.batchUpdate(false);\n    }\n    // load any passed in children as well, which overrides any DOM layout done above\n    if (this.opts.children) {\n      let children = this.opts.children;\n      delete this.opts.children;\n      if (children.length) this.load(children); // don't load empty\n    }\n\n    this.setAnimation(this.opts.animate);\n    this._updateStyles();\n    if (this.opts.column != 12) {\n      this.el.classList.add('grid-stack-' + this.opts.column);\n    }\n    // legacy support to appear 'per grid` options when really global.\n    if (this.opts.dragIn) GridStack.setupDragIn(this.opts.dragIn, this.opts.dragInOptions);\n    delete this.opts.dragIn;\n    delete this.opts.dragInOptions;\n    // dynamic grids require pausing during drag to detect over to nest vs push\n    if (this.opts.subGridDynamic && !dd_manager_1.DDManager.pauseDrag) dd_manager_1.DDManager.pauseDrag = true;\n    if (((_b = this.opts.draggable) === null || _b === void 0 ? void 0 : _b.pause) !== undefined) dd_manager_1.DDManager.pauseDrag = this.opts.draggable.pause;\n    this._setupRemoveDrop();\n    this._setupAcceptWidget();\n    this._updateWindowResizeEvent();\n  }\n  /**\r\n   * initializing the HTML element, or selector string, into a grid will return the grid. Calling it again will\r\n   * simply return the existing instance (ignore any passed options). There is also an initAll() version that support\r\n   * multiple grids initialization at once. Or you can use addGrid() to create the entire grid from JSON.\r\n   * @param options grid options (optional)\r\n   * @param elOrString element or CSS selector (first one used) to convert to a grid (default to '.grid-stack' class selector)\r\n   *\r\n   * @example\r\n   * let grid = GridStack.init();\r\n   *\r\n   * Note: the HTMLElement (of type GridHTMLElement) will store a `gridstack: GridStack` value that can be retrieve later\r\n   * let grid = document.querySelector('.grid-stack').gridstack;\r\n   */\n  static init() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let elOrString = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '.grid-stack';\n    let el = GridStack.getGridElement(elOrString);\n    if (!el) {\n      if (typeof elOrString === 'string') {\n        console.error('GridStack.initAll() no grid was found with selector \"' + elOrString + '\" - element missing or wrong selector ?' + '\\nNote: \".grid-stack\" is required for proper CSS styling and drag/drop, and is the default selector.');\n      } else {\n        console.error('GridStack.init() no grid element was passed.');\n      }\n      return null;\n    }\n    if (!el.gridstack) {\n      el.gridstack = new GridStack(el, utils_1.Utils.cloneDeep(options));\n    }\n    return el.gridstack;\n  }\n  /**\r\n   * Will initialize a list of elements (given a selector) and return an array of grids.\r\n   * @param options grid options (optional)\r\n   * @param selector elements selector to convert to grids (default to '.grid-stack' class selector)\r\n   *\r\n   * @example\r\n   * let grids = GridStack.initAll();\r\n   * grids.forEach(...)\r\n   */\n  static initAll() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let selector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '.grid-stack';\n    let grids = [];\n    GridStack.getGridElements(selector).forEach(el => {\n      if (!el.gridstack) {\n        el.gridstack = new GridStack(el, utils_1.Utils.cloneDeep(options));\n        delete options.dragIn;\n        delete options.dragInOptions; // only need to be done once (really a static global thing, not per grid)\n      }\n\n      grids.push(el.gridstack);\n    });\n    if (grids.length === 0) {\n      console.error('GridStack.initAll() no grid was found with selector \"' + selector + '\" - element missing or wrong selector ?' + '\\nNote: \".grid-stack\" is required for proper CSS styling and drag/drop, and is the default selector.');\n    }\n    return grids;\n  }\n  /**\r\n   * call to create a grid with the given options, including loading any children from JSON structure. This will call GridStack.init(), then\r\n   * grid.load() on any passed children (recursively). Great alternative to calling init() if you want entire grid to come from\r\n   * JSON serialized data, including options.\r\n   * @param parent HTML element parent to the grid\r\n   * @param opt grids options used to initialize the grid, and list of children\r\n   */\n  static addGrid(parent) {\n    let opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!parent) return null;\n    // create the grid element, but check if the passed 'parent' already has grid styling and should be used instead\n    let el = parent;\n    if (!parent.classList.contains('grid-stack')) {\n      let doc = document.implementation.createHTMLDocument(''); // IE needs a param\n      doc.body.innerHTML = `<div class=\"grid-stack ${opt.class || ''}\"></div>`;\n      el = doc.body.children[0];\n      parent.appendChild(el);\n    }\n    // create grid class and load any children\n    let grid = GridStack.init(opt, el);\n    return grid;\n  }\n  /** call this method to register your engine instead of the default one.\r\n   * See instead `GridStackOptions.engineClass` if you only need to\r\n   * replace just one instance.\r\n   */\n  static registerEngine(engineClass) {\n    GridStack.engineClass = engineClass;\n  }\n  /** @internal create placeholder DIV as needed */\n  get placeholder() {\n    if (!this._placeholder) {\n      let placeholderChild = document.createElement('div'); // child so padding match item-content\n      placeholderChild.className = 'placeholder-content';\n      if (this.opts.placeholderText) {\n        placeholderChild.innerHTML = this.opts.placeholderText;\n      }\n      this._placeholder = document.createElement('div');\n      this._placeholder.classList.add(this.opts.placeholderClass, types_1.gridDefaults.itemClass, this.opts.itemClass);\n      this.placeholder.appendChild(placeholderChild);\n    }\n    return this._placeholder;\n  }\n  /**\r\n   * add a new widget and returns it.\r\n   *\r\n   * Widget will be always placed even if result height is more than actual grid height.\r\n   * You need to use `willItFit()` before calling addWidget for additional check.\r\n   * See also `makeWidget()`.\r\n   *\r\n   * @example\r\n   * let grid = GridStack.init();\r\n   * grid.addWidget({w: 3, content: 'hello'});\r\n   * grid.addWidget('<div class=\"grid-stack-item\"><div class=\"grid-stack-item-content\">hello</div></div>', {w: 3});\r\n   *\r\n   * @param el  GridStackWidget (which can have content string as well), html element, or string definition to add\r\n   * @param options widget position/size options (optional, and ignore if first param is already option) - see GridStackWidget\r\n   */\n  addWidget(els, options) {\n    function isGridStackWidget(w) {\n      return w.el !== undefined || w.x !== undefined || w.y !== undefined || w.w !== undefined || w.h !== undefined || w.content !== undefined ? true : false;\n    }\n    let el;\n    let node;\n    if (typeof els === 'string') {\n      let doc = document.implementation.createHTMLDocument(''); // IE needs a param\n      doc.body.innerHTML = els;\n      el = doc.body.children[0];\n    } else if (arguments.length === 0 || arguments.length === 1 && isGridStackWidget(els)) {\n      node = options = els;\n      if (node === null || node === void 0 ? void 0 : node.el) {\n        el = node.el; // re-use element stored in the node\n      } else if (this.opts.addRemoveCB) {\n        el = this.opts.addRemoveCB(this, options, true);\n      } else {\n        let content = (options === null || options === void 0 ? void 0 : options.content) || '';\n        let doc = document.implementation.createHTMLDocument(''); // IE needs a param\n        doc.body.innerHTML = `<div class=\"grid-stack-item ${this.opts.itemClass || ''}\"><div class=\"grid-stack-item-content\">${content}</div></div>`;\n        el = doc.body.children[0];\n      }\n    } else {\n      el = els;\n    }\n    if (!el) return;\n    // Tempting to initialize the passed in opt with default and valid values, but this break knockout demos\n    // as the actual value are filled in when _prepareElement() calls el.getAttribute('gs-xyz') before adding the node.\n    // So make sure we load any DOM attributes that are not specified in passed in options (which override)\n    let domAttr = this._readAttr(el);\n    options = utils_1.Utils.cloneDeep(options) || {}; // make a copy before we modify in case caller re-uses it\n    utils_1.Utils.defaults(options, domAttr);\n    node = this.engine.prepareNode(options);\n    this._writeAttr(el, options);\n    if (this._insertNotAppend) {\n      this.el.prepend(el);\n    } else {\n      this.el.appendChild(el);\n    }\n    // similar to makeWidget() that doesn't read attr again and worse re-create a new node and loose any _id\n    this._prepareElement(el, true, options);\n    this._updateContainerHeight();\n    // see if there is a sub-grid to create\n    if (node.subGrid) {\n      this.makeSubGrid(node.el, undefined, undefined, false);\n    }\n    // if we're adding an item into 1 column (_prevColumn is set only when going to 1) make sure\n    // we don't override the larger 12 column layout that was already saved. #1985\n    if (this._prevColumn && this.opts.column === 1) {\n      this._ignoreLayoutsNodeChange = true;\n    }\n    this._triggerAddEvent();\n    this._triggerChangeEvent();\n    delete this._ignoreLayoutsNodeChange;\n    return el;\n  }\n  /**\r\n   * Convert an existing gridItem element into a sub-grid with the given (optional) options, else inherit them\r\n   * from the parent's subGrid options.\r\n   * @param el gridItem element to convert\r\n   * @param ops (optional) sub-grid options, else default to node, then parent settings, else defaults\r\n   * @param nodeToAdd (optional) node to add to the newly created sub grid (used when dragging over existing regular item)\r\n   * @returns newly created grid\r\n   */\n  makeSubGrid(el, ops, nodeToAdd) {\n    let saveContent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var _a, _b, _c;\n    let node = el.gridstackNode;\n    if (!node) {\n      node = this.makeWidget(el).gridstackNode;\n    }\n    if ((_a = node.subGrid) === null || _a === void 0 ? void 0 : _a.el) return node.subGrid; // already done\n    // find the template subGrid stored on a parent as fallback...\n    let subGridTemplate; // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let grid = this;\n    while (grid && !subGridTemplate) {\n      subGridTemplate = (_b = grid.opts) === null || _b === void 0 ? void 0 : _b.subGrid;\n      grid = (_c = grid.parentGridItem) === null || _c === void 0 ? void 0 : _c.grid;\n    }\n    //... and set the create options\n    ops = utils_1.Utils.cloneDeep(Object.assign(Object.assign(Object.assign({}, subGridTemplate || {}), {\n      children: undefined\n    }), ops || node.subGrid));\n    node.subGrid = ops;\n    // if column special case it set, remember that flag and set default\n    let autoColumn;\n    if (ops.column === 'auto') {\n      autoColumn = true;\n      ops.column = Math.max(node.w || 1, (nodeToAdd === null || nodeToAdd === void 0 ? void 0 : nodeToAdd.w) || 1);\n      ops.disableOneColumnMode = true; // driven by parent\n    }\n    // if we're converting an existing full item, move over the content to be the first sub item in the new grid\n    // TODO: support this.opts.addRemoveCB for frameworks\n    let content = node.el.querySelector('.grid-stack-item-content');\n    let newItem;\n    let newItemOpt;\n    if (saveContent) {\n      this._removeDD(node.el); // remove D&D since it's set on content div\n      let doc = document.implementation.createHTMLDocument(''); // IE needs a param\n      doc.body.innerHTML = `<div class=\"grid-stack-item\"></div>`;\n      newItem = doc.body.children[0];\n      newItem.appendChild(content);\n      newItemOpt = Object.assign(Object.assign({}, node), {\n        x: 0,\n        y: 0\n      });\n      utils_1.Utils.removeInternalForSave(newItemOpt);\n      delete newItemOpt.subGrid;\n      if (node.content) {\n        newItemOpt.content = node.content;\n        delete node.content;\n      }\n      doc.body.innerHTML = `<div class=\"grid-stack-item-content\"></div>`;\n      content = doc.body.children[0];\n      node.el.appendChild(content);\n      this._prepareDragDropByNode(node); // ... and restore original D&D\n    }\n    // if we're adding an additional item, make the container large enough to have them both\n    if (nodeToAdd) {\n      let w = autoColumn ? ops.column : node.w;\n      let h = node.h + nodeToAdd.h;\n      let style = node.el.style;\n      style.transition = 'none'; // show up instantly so we don't see scrollbar with nodeToAdd\n      this.update(node.el, {\n        w,\n        h\n      });\n      setTimeout(() => style.transition = null); // recover animation\n    }\n\n    let subGrid = node.subGrid = GridStack.addGrid(content, ops);\n    if (nodeToAdd === null || nodeToAdd === void 0 ? void 0 : nodeToAdd._moving) subGrid._isTemp = true; // prevent re-nesting as we add over\n    if (autoColumn) subGrid._autoColumn = true;\n    // add the original content back as a child of hte newly created grid\n    if (saveContent) {\n      subGrid.addWidget(newItem, newItemOpt);\n    }\n    // now add any additional node\n    if (nodeToAdd) {\n      if (nodeToAdd._moving) {\n        // create an artificial event even for the just created grid to receive this item\n        window.setTimeout(() => utils_1.Utils.simulateMouseEvent(nodeToAdd._event, 'mouseenter', subGrid.el), 0);\n      } else {\n        subGrid.addWidget(node.el, node);\n      }\n    }\n    return subGrid;\n  }\n  /**\r\n   * called when an item was converted into a nested grid to accommodate a dragged over item, but then item leaves - return back\r\n   * to the original grid-item. Also called to remove empty sub-grids when last item is dragged out (since re-creating is simple)\r\n   */\n  removeAsSubGrid(nodeThatRemoved) {\n    var _a;\n    let pGrid = (_a = this.parentGridItem) === null || _a === void 0 ? void 0 : _a.grid;\n    if (!pGrid) return;\n    pGrid.batchUpdate();\n    pGrid.removeWidget(this.parentGridItem.el, true, true);\n    this.engine.nodes.forEach(n => {\n      // migrate any children over and offsetting by our location\n      n.x += this.parentGridItem.x;\n      n.y += this.parentGridItem.y;\n      pGrid.addWidget(n.el, n);\n    });\n    pGrid.batchUpdate(false);\n    delete this.parentGridItem;\n    // create an artificial event for the original grid now that this one is gone (got a leave, but won't get enter)\n    if (nodeThatRemoved) {\n      window.setTimeout(() => utils_1.Utils.simulateMouseEvent(nodeThatRemoved._event, 'mouseenter', pGrid.el), 0);\n    }\n  }\n  /**\r\n  /**\r\n   * saves the current layout returning a list of widgets for serialization which might include any nested grids.\r\n   * @param saveContent if true (default) the latest html inside .grid-stack-content will be saved to GridStackWidget.content field, else it will\r\n   * be removed.\r\n   * @param saveGridOpt if true (default false), save the grid options itself, so you can call the new GridStack.addGrid()\r\n   * to recreate everything from scratch. GridStackOptions.children would then contain the widget list instead.\r\n   * @returns list of widgets or full grid option, including .children list of widgets\r\n   */\n  save() {\n    let saveContent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let saveGridOpt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    // return copied nodes we can modify at will...\n    let list = this.engine.save(saveContent);\n    // check for HTML content and nested grids\n    list.forEach(n => {\n      var _a;\n      if (saveContent && n.el && !n.subGrid) {\n        // sub-grid are saved differently, not plain content\n        let sub = n.el.querySelector('.grid-stack-item-content');\n        n.content = sub ? sub.innerHTML : undefined;\n        if (!n.content) delete n.content;\n      } else {\n        if (!saveContent) {\n          delete n.content;\n        }\n        // check for nested grid\n        if ((_a = n.subGrid) === null || _a === void 0 ? void 0 : _a.el) {\n          const listOrOpt = n.subGrid.save(saveContent, saveGridOpt);\n          n.subGrid = saveGridOpt ? listOrOpt : {\n            children: listOrOpt\n          };\n        }\n      }\n      delete n.el;\n    });\n    // check if save entire grid options (needed for recursive) + children...\n    if (saveGridOpt) {\n      let o = utils_1.Utils.cloneDeep(this.opts);\n      // delete default values that will be recreated on launch\n      if (o.marginBottom === o.marginTop && o.marginRight === o.marginLeft && o.marginTop === o.marginRight) {\n        o.margin = o.marginTop;\n        delete o.marginTop;\n        delete o.marginRight;\n        delete o.marginBottom;\n        delete o.marginLeft;\n      }\n      if (o.rtl === (this.el.style.direction === 'rtl')) {\n        o.rtl = 'auto';\n      }\n      if (this._isAutoCellHeight) {\n        o.cellHeight = 'auto';\n      }\n      if (this._autoColumn) {\n        o.column = 'auto';\n        delete o.disableOneColumnMode;\n      }\n      const origShow = o._alwaysShowResizeHandle;\n      delete o._alwaysShowResizeHandle;\n      if (origShow !== undefined) {\n        o.alwaysShowResizeHandle = origShow;\n      } else {\n        delete o.alwaysShowResizeHandle;\n      }\n      utils_1.Utils.removeInternalAndSame(o, types_1.gridDefaults);\n      o.children = list;\n      return o;\n    }\n    return list;\n  }\n  /**\r\n   * load the widgets from a list. This will call update() on each (matching by id) or add/remove widgets that are not there.\r\n   *\r\n   * @param layout list of widgets definition to update/create\r\n   * @param addAndRemove boolean (default true) or callback method can be passed to control if and how missing widgets can be added/removed, giving\r\n   * the user control of insertion.\r\n   *\r\n   * @example\r\n   * see http://gridstackjs.com/demo/serialization.html\r\n   **/\n  load(layout) {\n    let addRemove = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.opts.addRemoveCB || true;\n    let items = GridStack.Utils.sort([...layout], -1, this._prevColumn || this.getColumn()); // make copy before we mod/sort\n    this._insertNotAppend = true; // since create in reverse order...\n    // if we're loading a layout into for example 1 column (_prevColumn is set only when going to 1) and items don't fit, make sure to save\n    // the original wanted layout so we can scale back up correctly #1471\n    if (this._prevColumn && this._prevColumn !== this.opts.column && items.some(n => n.x + n.w > this.opts.column)) {\n      this._ignoreLayoutsNodeChange = true; // skip layout update\n      this.engine.cacheLayout(items, this._prevColumn, true);\n    }\n    // if given a different callback, temporally set it as global option to creating will use it\n    const prevCB = this.opts.addRemoveCB;\n    if (typeof addRemove === 'function') this.opts.addRemoveCB = addRemove;\n    let removed = [];\n    this.batchUpdate();\n    // see if any items are missing from new layout and need to be removed first\n    if (addRemove) {\n      let copyNodes = [...this.engine.nodes]; // don't loop through array you modify\n      copyNodes.forEach(n => {\n        let item = items.find(w => n.id === w.id);\n        if (!item) {\n          if (this.opts.addRemoveCB) this.opts.addRemoveCB(this, n, false);\n          removed.push(n); // batch keep track\n          this.removeWidget(n.el, true, false);\n        }\n      });\n    }\n    // now add/update the widgets\n    items.forEach(w => {\n      let item = w.id || w.id === 0 ? this.engine.nodes.find(n => n.id === w.id) : undefined;\n      if (item) {\n        this.update(item.el, w);\n        if (w.subGrid && w.subGrid.children) {\n          // update any sub grid as well\n          let sub = item.el.querySelector('.grid-stack');\n          if (sub && sub.gridstack) {\n            sub.gridstack.load(w.subGrid.children); // TODO: support updating grid options ?\n            this._insertNotAppend = true; // got reset by above call\n          }\n        }\n      } else if (addRemove) {\n        this.addWidget(w);\n      }\n    });\n    this.engine.removedNodes = removed;\n    this.batchUpdate(false);\n    // after commit, clear that flag\n    delete this._ignoreLayoutsNodeChange;\n    delete this._insertNotAppend;\n    prevCB ? this.opts.addRemoveCB = prevCB : delete this.opts.addRemoveCB;\n    return this;\n  }\n  /**\r\n   * use before calling a bunch of `addWidget()` to prevent un-necessary relayouts in between (more efficient)\r\n   * and get a single event callback. You will see no changes until `batchUpdate(false)` is called.\r\n   */\n  batchUpdate() {\n    let flag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this.engine.batchUpdate(flag);\n    if (!flag) {\n      this._triggerRemoveEvent();\n      this._triggerAddEvent();\n      this._triggerChangeEvent();\n    }\n    return this;\n  }\n  /**\r\n   * Gets current cell height.\r\n   */\n  getCellHeight() {\n    let forcePixel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.opts.cellHeight && this.opts.cellHeight !== 'auto' && (!forcePixel || !this.opts.cellHeightUnit || this.opts.cellHeightUnit === 'px')) {\n      return this.opts.cellHeight;\n    }\n    // else get first cell height\n    let el = this.el.querySelector('.' + this.opts.itemClass);\n    if (el) {\n      let height = utils_1.Utils.toNumber(el.getAttribute('gs-h'));\n      return Math.round(el.offsetHeight / height);\n    }\n    // else do entire grid and # of rows (but doesn't work if min-height is the actual constrain)\n    let rows = parseInt(this.el.getAttribute('gs-current-row'));\n    return rows ? Math.round(this.el.getBoundingClientRect().height / rows) : this.opts.cellHeight;\n  }\n  /**\r\n   * Update current cell height - see `GridStackOptions.cellHeight` for format.\r\n   * This method rebuilds an internal CSS style sheet.\r\n   * Note: You can expect performance issues if call this method too often.\r\n   *\r\n   * @param val the cell height. If not passed (undefined), cells content will be made square (match width minus margin),\r\n   * if pass 0 the CSS will be generated by the application instead.\r\n   * @param update (Optional) if false, styles will not be updated\r\n   *\r\n   * @example\r\n   * grid.cellHeight(100); // same as 100px\r\n   * grid.cellHeight('70px');\r\n   * grid.cellHeight(grid.cellWidth() * 1.2);\r\n   */\n  cellHeight(val) {\n    let update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    // if not called internally, check if we're changing mode\n    if (update && val !== undefined) {\n      if (this._isAutoCellHeight !== (val === 'auto')) {\n        this._isAutoCellHeight = val === 'auto';\n        this._updateWindowResizeEvent();\n      }\n    }\n    if (val === 'initial' || val === 'auto') {\n      val = undefined;\n    }\n    // make item content be square\n    if (val === undefined) {\n      let marginDiff = -this.opts.marginRight - this.opts.marginLeft + this.opts.marginTop + this.opts.marginBottom;\n      val = this.cellWidth() + marginDiff;\n    }\n    let data = utils_1.Utils.parseHeight(val);\n    if (this.opts.cellHeightUnit === data.unit && this.opts.cellHeight === data.h) {\n      return this;\n    }\n    this.opts.cellHeightUnit = data.unit;\n    this.opts.cellHeight = data.h;\n    if (update) {\n      this._updateStyles(true); // true = force re-create for current # of rows\n    }\n\n    return this;\n  }\n  /** Gets current cell width. */\n  cellWidth() {\n    return this._widthOrContainer() / this.getColumn();\n  }\n  /** return our expected width (or parent) for 1 column check */\n  _widthOrContainer() {\n    // use `offsetWidth` or `clientWidth` (no scrollbar) ?\n    // https://stackoverflow.com/questions/21064101/understanding-offsetwidth-clientwidth-scrollwidth-and-height-respectively\n    return this.el.clientWidth || this.el.parentElement.clientWidth || window.innerWidth;\n  }\n  /** re-layout grid items to reclaim any empty space */\n  compact() {\n    this.engine.compact();\n    this._triggerChangeEvent();\n    return this;\n  }\n  /**\r\n   * set the number of columns in the grid. Will update existing widgets to conform to new number of columns,\r\n   * as well as cache the original layout so you can revert back to previous positions without loss.\r\n   * Requires `gridstack-extra.css` or `gridstack-extra.min.css` for [2-11],\r\n   * else you will need to generate correct CSS (see https://github.com/gridstack/gridstack.js#change-grid-columns)\r\n   * @param column - Integer > 0 (default 12).\r\n   * @param layout specify the type of re-layout that will happen (position, size, etc...).\r\n   * Note: items will never be outside of the current column boundaries. default (moveScale). Ignored for 1 column\r\n   */\n  column(column) {\n    let layout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'moveScale';\n    if (column < 1 || this.opts.column === column) return this;\n    let oldColumn = this.getColumn();\n    // if we go into 1 column mode (which happens if we're sized less than minW unless disableOneColumnMode is on)\n    // then remember the original columns so we can restore.\n    if (column === 1) {\n      this._prevColumn = oldColumn;\n    } else {\n      delete this._prevColumn;\n    }\n    this.el.classList.remove('grid-stack-' + oldColumn);\n    this.el.classList.add('grid-stack-' + column);\n    this.opts.column = this.engine.column = column;\n    // update the items now - see if the dom order nodes should be passed instead (else default to current list)\n    let domNodes;\n    if (column === 1 && this.opts.oneColumnModeDomSort) {\n      domNodes = [];\n      this.getGridItems().forEach(el => {\n        if (el.gridstackNode) {\n          domNodes.push(el.gridstackNode);\n        }\n      });\n      if (!domNodes.length) {\n        domNodes = undefined;\n      }\n    }\n    this.engine.updateNodeWidths(oldColumn, column, domNodes, layout);\n    if (this._isAutoCellHeight) this.cellHeight();\n    // and trigger our event last...\n    this._ignoreLayoutsNodeChange = true; // skip layout update\n    this._triggerChangeEvent();\n    delete this._ignoreLayoutsNodeChange;\n    return this;\n  }\n  /**\r\n   * get the number of columns in the grid (default 12)\r\n   */\n  getColumn() {\n    return this.opts.column;\n  }\n  /** returns an array of grid HTML elements (no placeholder) - used to iterate through our children in DOM order */\n  getGridItems() {\n    return Array.from(this.el.children).filter(el => el.matches('.' + this.opts.itemClass) && !el.matches('.' + this.opts.placeholderClass));\n  }\n  /**\r\n   * Destroys a grid instance. DO NOT CALL any methods or access any vars after this as it will free up members.\r\n   * @param removeDOM if `false` grid and items HTML elements will not be removed from the DOM (Optional. Default `true`).\r\n   */\n  destroy() {\n    let removeDOM = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (!this.el) return; // prevent multiple calls\n    this._updateWindowResizeEvent(true);\n    this.setStatic(true, false); // permanently removes DD but don't set CSS class (we're going away)\n    this.setAnimation(false);\n    if (!removeDOM) {\n      this.removeAll(removeDOM);\n      this.el.classList.remove(this._styleSheetClass);\n    } else {\n      this.el.parentNode.removeChild(this.el);\n    }\n    this._removeStylesheet();\n    this.el.removeAttribute('gs-current-row');\n    delete this.parentGridItem;\n    delete this.opts;\n    delete this._placeholder;\n    delete this.engine;\n    delete this.el.gridstack; // remove circular dependency that would prevent a freeing\n    delete this.el;\n    return this;\n  }\n  /**\r\n   * enable/disable floating widgets (default: `false`) See [example](http://gridstackjs.com/demo/float.html)\r\n   */\n  float(val) {\n    if (this.opts.float !== val) {\n      this.opts.float = this.engine.float = val;\n      this._triggerChangeEvent();\n    }\n    return this;\n  }\n  /**\r\n   * get the current float mode\r\n   */\n  getFloat() {\n    return this.engine.float;\n  }\n  /**\r\n   * Get the position of the cell under a pixel on screen.\r\n   * @param position the position of the pixel to resolve in\r\n   * absolute coordinates, as an object with top and left properties\r\n   * @param useDocRelative if true, value will be based on document position vs parent position (Optional. Default false).\r\n   * Useful when grid is within `position: relative` element\r\n   *\r\n   * Returns an object with properties `x` and `y` i.e. the column and row in the grid.\r\n   */\n  getCellFromPixel(position) {\n    let useDocRelative = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let box = this.el.getBoundingClientRect();\n    // console.log(`getBoundingClientRect left: ${box.left} top: ${box.top} w: ${box.w} h: ${box.h}`)\n    let containerPos;\n    if (useDocRelative) {\n      containerPos = {\n        top: box.top + document.documentElement.scrollTop,\n        left: box.left\n      };\n      // console.log(`getCellFromPixel scrollTop: ${document.documentElement.scrollTop}`)\n    } else {\n      containerPos = {\n        top: this.el.offsetTop,\n        left: this.el.offsetLeft\n      };\n      // console.log(`getCellFromPixel offsetTop: ${containerPos.left} offsetLeft: ${containerPos.top}`)\n    }\n\n    let relativeLeft = position.left - containerPos.left;\n    let relativeTop = position.top - containerPos.top;\n    let columnWidth = box.width / this.getColumn();\n    let rowHeight = box.height / parseInt(this.el.getAttribute('gs-current-row'));\n    return {\n      x: Math.floor(relativeLeft / columnWidth),\n      y: Math.floor(relativeTop / rowHeight)\n    };\n  }\n  /** returns the current number of rows, which will be at least `minRow` if set */\n  getRow() {\n    return Math.max(this.engine.getRow(), this.opts.minRow);\n  }\n  /**\r\n   * Checks if specified area is empty.\r\n   * @param x the position x.\r\n   * @param y the position y.\r\n   * @param w the width of to check\r\n   * @param h the height of to check\r\n   */\n  isAreaEmpty(x, y, w, h) {\n    return this.engine.isAreaEmpty(x, y, w, h);\n  }\n  /**\r\n   * If you add elements to your grid by hand, you have to tell gridstack afterwards to make them widgets.\r\n   * If you want gridstack to add the elements for you, use `addWidget()` instead.\r\n   * Makes the given element a widget and returns it.\r\n   * @param els widget or single selector to convert.\r\n   *\r\n   * @example\r\n   * let grid = GridStack.init();\r\n   * grid.el.appendChild('<div id=\"gsi-1\" gs-w=\"3\"></div>');\r\n   * grid.makeWidget('#gsi-1');\r\n   */\n  makeWidget(els) {\n    let el = GridStack.getElement(els);\n    this._prepareElement(el, true);\n    this._updateContainerHeight();\n    this._triggerAddEvent();\n    this._triggerChangeEvent();\n    return el;\n  }\n  /**\r\n   * Event handler that extracts our CustomEvent data out automatically for receiving custom\r\n   * notifications (see doc for supported events)\r\n   * @param name of the event (see possible values) or list of names space separated\r\n   * @param callback function called with event and optional second/third param\r\n   * (see README documentation for each signature).\r\n   *\r\n   * @example\r\n   * grid.on('added', function(e, items) { log('added ', items)} );\r\n   * or\r\n   * grid.on('added removed change', function(e, items) { log(e.type, items)} );\r\n   *\r\n   * Note: in some cases it is the same as calling native handler and parsing the event.\r\n   * grid.el.addEventListener('added', function(event) { log('added ', event.detail)} );\r\n   *\r\n   */\n  on(name, callback) {\n    // check for array of names being passed instead\n    if (name.indexOf(' ') !== -1) {\n      let names = name.split(' ');\n      names.forEach(name => this.on(name, callback));\n      return this;\n    }\n    if (name === 'change' || name === 'added' || name === 'removed' || name === 'enable' || name === 'disable') {\n      // native CustomEvent handlers - cash the generic handlers so we can easily remove\n      let noData = name === 'enable' || name === 'disable';\n      if (noData) {\n        this._gsEventHandler[name] = event => callback(event);\n      } else {\n        this._gsEventHandler[name] = event => callback(event, event.detail);\n      }\n      this.el.addEventListener(name, this._gsEventHandler[name]);\n    } else if (name === 'drag' || name === 'dragstart' || name === 'dragstop' || name === 'resizestart' || name === 'resize' || name === 'resizestop' || name === 'dropped') {\n      // drag&drop stop events NEED to be call them AFTER we update node attributes so handle them ourself.\n      // do same for start event to make it easier...\n      this._gsEventHandler[name] = callback;\n    } else {\n      console.log('GridStack.on(' + name + ') event not supported, but you can still use $(\".grid-stack\").on(...) while jquery-ui is still used internally.');\n    }\n    return this;\n  }\n  /**\r\n   * unsubscribe from the 'on' event below\r\n   * @param name of the event (see possible values)\r\n   */\n  off(name) {\n    // check for array of names being passed instead\n    if (name.indexOf(' ') !== -1) {\n      let names = name.split(' ');\n      names.forEach(name => this.off(name));\n      return this;\n    }\n    if (name === 'change' || name === 'added' || name === 'removed' || name === 'enable' || name === 'disable') {\n      // remove native CustomEvent handlers\n      if (this._gsEventHandler[name]) {\n        this.el.removeEventListener(name, this._gsEventHandler[name]);\n      }\n    }\n    delete this._gsEventHandler[name];\n    return this;\n  }\n  /**\r\n   * Removes widget from the grid.\r\n   * @param el  widget or selector to modify\r\n   * @param removeDOM if `false` DOM element won't be removed from the tree (Default? true).\r\n   * @param triggerEvent if `false` (quiet mode) element will not be added to removed list and no 'removed' callbacks will be called (Default? true).\r\n   */\n  removeWidget(els) {\n    let removeDOM = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let triggerEvent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    GridStack.getElements(els).forEach(el => {\n      if (el.parentElement && el.parentElement !== this.el) return; // not our child!\n      let node = el.gridstackNode;\n      // For Meteor support: https://github.com/gridstack/gridstack.js/pull/272\n      if (!node) {\n        node = this.engine.nodes.find(n => el === n.el);\n      }\n      if (!node) return;\n      // remove our DOM data (circular link) and drag&drop permanently\n      delete el.gridstackNode;\n      this._removeDD(el);\n      this.engine.removeNode(node, removeDOM, triggerEvent);\n      if (removeDOM && el.parentElement) {\n        el.remove(); // in batch mode engine.removeNode doesn't call back to remove DOM\n      }\n    });\n\n    if (triggerEvent) {\n      this._triggerRemoveEvent();\n      this._triggerChangeEvent();\n    }\n    return this;\n  }\n  /**\r\n   * Removes all widgets from the grid.\r\n   * @param removeDOM if `false` DOM elements won't be removed from the tree (Default? `true`).\r\n   */\n  removeAll() {\n    let removeDOM = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    // always remove our DOM data (circular link) before list gets emptied and drag&drop permanently\n    this.engine.nodes.forEach(n => {\n      delete n.el.gridstackNode;\n      this._removeDD(n.el);\n    });\n    this.engine.removeAll(removeDOM);\n    this._triggerRemoveEvent();\n    return this;\n  }\n  /**\r\n   * Toggle the grid animation state.  Toggles the `grid-stack-animate` class.\r\n   * @param doAnimate if true the grid will animate.\r\n   */\n  setAnimation(doAnimate) {\n    if (doAnimate) {\n      this.el.classList.add('grid-stack-animate');\n    } else {\n      this.el.classList.remove('grid-stack-animate');\n    }\n    return this;\n  }\n  /**\r\n   * Toggle the grid static state, which permanently removes/add Drag&Drop support, unlike disable()/enable() that just turns it off/on.\r\n   * Also toggle the grid-stack-static class.\r\n   * @param val if true the grid become static.\r\n   * @param updateClass true (default) if css class gets updated\r\n   * @param recurse true (default) if sub-grids also get updated\r\n   */\n  setStatic(val) {\n    let updateClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let recurse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    if (this.opts.staticGrid === val) return this;\n    this.opts.staticGrid = val;\n    this._setupRemoveDrop();\n    this._setupAcceptWidget();\n    this.engine.nodes.forEach(n => {\n      this._prepareDragDropByNode(n); // either delete or init Drag&drop\n      if (n.subGrid && recurse) n.subGrid.setStatic(val, updateClass, recurse);\n    });\n    if (updateClass) {\n      this._setStaticClass();\n    }\n    return this;\n  }\n  /**\r\n   * Updates widget position/size and other info. Note: if you need to call this on all nodes, use load() instead which will update what changed.\r\n   * @param els  widget or selector of objects to modify (note: setting the same x,y for multiple items will be indeterministic and likely unwanted)\r\n   * @param opt new widget options (x,y,w,h, etc..). Only those set will be updated.\r\n   */\n  update(els, opt) {\n    // support legacy call for now ?\n    if (arguments.length > 2) {\n      console.warn('gridstack.ts: `update(el, x, y, w, h)` is deprecated. Use `update(el, {x, w, content, ...})`. It will be removed soon');\n      // eslint-disable-next-line prefer-rest-params\n      let a = arguments,\n        i = 1;\n      opt = {\n        x: a[i++],\n        y: a[i++],\n        w: a[i++],\n        h: a[i++]\n      };\n      return this.update(els, opt);\n    }\n    GridStack.getElements(els).forEach(el => {\n      if (!el || !el.gridstackNode) return;\n      let n = el.gridstackNode;\n      let w = utils_1.Utils.cloneDeep(opt); // make a copy we can modify in case they re-use it or multiple items\n      delete w.autoPosition;\n      // move/resize widget if anything changed\n      let keys = ['x', 'y', 'w', 'h'];\n      let m;\n      if (keys.some(k => w[k] !== undefined && w[k] !== n[k])) {\n        m = {};\n        keys.forEach(k => {\n          m[k] = w[k] !== undefined ? w[k] : n[k];\n          delete w[k];\n        });\n      }\n      // for a move as well IFF there is any min/max fields set\n      if (!m && (w.minW || w.minH || w.maxW || w.maxH)) {\n        m = {}; // will use node position but validate values\n      }\n      // check for content changing\n      if (w.content) {\n        let sub = el.querySelector('.grid-stack-item-content');\n        if (sub && sub.innerHTML !== w.content) {\n          sub.innerHTML = w.content;\n        }\n        delete w.content;\n      }\n      // any remaining fields are assigned, but check for dragging changes, resize constrain\n      let changed = false;\n      let ddChanged = false;\n      for (const key in w) {\n        if (key[0] !== '_' && n[key] !== w[key]) {\n          n[key] = w[key];\n          changed = true;\n          ddChanged = ddChanged || !this.opts.staticGrid && (key === 'noResize' || key === 'noMove' || key === 'locked');\n        }\n      }\n      // finally move the widget\n      if (m) {\n        this.engine.cleanNodes().beginUpdate(n).moveNode(n, m);\n        this._updateContainerHeight();\n        this._triggerChangeEvent();\n        this.engine.endUpdate();\n      }\n      if (changed) {\n        // move will only update x,y,w,h so update the rest too\n        this._writeAttr(el, n);\n      }\n      if (ddChanged) {\n        this._prepareDragDropByNode(n);\n      }\n    });\n    return this;\n  }\n  /**\r\n   * Updates the margins which will set all 4 sides at once - see `GridStackOptions.margin` for format options (CSS string format of 1,2,4 values or single number).\r\n   * @param value margin value\r\n   */\n  margin(value) {\n    let isMultiValue = typeof value === 'string' && value.split(' ').length > 1;\n    // check if we can skip re-creating our CSS file... won't check if multi values (too much hassle)\n    if (!isMultiValue) {\n      let data = utils_1.Utils.parseHeight(value);\n      if (this.opts.marginUnit === data.unit && this.opts.margin === data.h) return;\n    }\n    // re-use existing margin handling\n    this.opts.margin = value;\n    this.opts.marginTop = this.opts.marginBottom = this.opts.marginLeft = this.opts.marginRight = undefined;\n    this._initMargin();\n    this._updateStyles(true); // true = force re-create\n    return this;\n  }\n  /** returns current margin number value (undefined if 4 sides don't match) */\n  getMargin() {\n    return this.opts.margin;\n  }\n  /**\r\n   * Returns true if the height of the grid will be less than the vertical\r\n   * constraint. Always returns true if grid doesn't have height constraint.\r\n   * @param node contains x,y,w,h,auto-position options\r\n   *\r\n   * @example\r\n   * if (grid.willItFit(newWidget)) {\r\n   *   grid.addWidget(newWidget);\r\n   * } else {\r\n   *   alert('Not enough free space to place the widget');\r\n   * }\r\n   */\n  willItFit(node) {\n    // support legacy call for now\n    if (arguments.length > 1) {\n      console.warn('gridstack.ts: `willItFit(x,y,w,h,autoPosition)` is deprecated. Use `willItFit({x, y,...})`. It will be removed soon');\n      // eslint-disable-next-line prefer-rest-params\n      let a = arguments,\n        i = 0,\n        w = {\n          x: a[i++],\n          y: a[i++],\n          w: a[i++],\n          h: a[i++],\n          autoPosition: a[i++]\n        };\n      return this.willItFit(w);\n    }\n    return this.engine.willItFit(node);\n  }\n  /** @internal */\n  _triggerChangeEvent() {\n    if (this.engine.batchMode) return this;\n    let elements = this.engine.getDirtyNodes(true); // verify they really changed\n    if (elements && elements.length) {\n      if (!this._ignoreLayoutsNodeChange) {\n        this.engine.layoutsNodesChange(elements);\n      }\n      this._triggerEvent('change', elements);\n    }\n    this.engine.saveInitial(); // we called, now reset initial values & dirty flags\n    return this;\n  }\n  /** @internal */\n  _triggerAddEvent() {\n    if (this.engine.batchMode) return this;\n    if (this.engine.addedNodes && this.engine.addedNodes.length > 0) {\n      if (!this._ignoreLayoutsNodeChange) {\n        this.engine.layoutsNodesChange(this.engine.addedNodes);\n      }\n      // prevent added nodes from also triggering 'change' event (which is called next)\n      this.engine.addedNodes.forEach(n => {\n        delete n._dirty;\n      });\n      this._triggerEvent('added', this.engine.addedNodes);\n      this.engine.addedNodes = [];\n    }\n    return this;\n  }\n  /** @internal */\n  _triggerRemoveEvent() {\n    if (this.engine.batchMode) return this;\n    if (this.engine.removedNodes && this.engine.removedNodes.length > 0) {\n      this._triggerEvent('removed', this.engine.removedNodes);\n      this.engine.removedNodes = [];\n    }\n    return this;\n  }\n  /** @internal */\n  _triggerEvent(type, data) {\n    let event = data ? new CustomEvent(type, {\n      bubbles: false,\n      detail: data\n    }) : new Event(type);\n    this.el.dispatchEvent(event);\n    return this;\n  }\n  /** @internal called to delete the current dynamic style sheet used for our layout */\n  _removeStylesheet() {\n    if (this._styles) {\n      utils_1.Utils.removeStylesheet(this._styleSheetClass);\n      delete this._styles;\n    }\n    return this;\n  }\n  /** @internal updated/create the CSS styles for row based layout and initial margin setting */\n  _updateStyles() {\n    let forceUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let maxH = arguments.length > 1 ? arguments[1] : undefined;\n    // call to delete existing one if we change cellHeight / margin\n    if (forceUpdate) {\n      this._removeStylesheet();\n    }\n    if (!maxH) maxH = this.getRow();\n    this._updateContainerHeight();\n    // if user is telling us they will handle the CSS themselves by setting heights to 0. Do we need this opts really ??\n    if (this.opts.cellHeight === 0) {\n      return this;\n    }\n    let cellHeight = this.opts.cellHeight;\n    let cellHeightUnit = this.opts.cellHeightUnit;\n    let prefix = `.${this._styleSheetClass} > .${this.opts.itemClass}`;\n    // create one as needed\n    if (!this._styles) {\n      // insert style to parent (instead of 'head' by default) to support WebComponent\n      let styleLocation = this.opts.styleInHead ? undefined : this.el.parentNode;\n      this._styles = utils_1.Utils.createStylesheet(this._styleSheetClass, styleLocation);\n      if (!this._styles) return this;\n      this._styles._max = 0;\n      // these are done once only\n      utils_1.Utils.addCSSRule(this._styles, prefix, `min-height: ${cellHeight}${cellHeightUnit}`);\n      // content margins\n      let top = this.opts.marginTop + this.opts.marginUnit;\n      let bottom = this.opts.marginBottom + this.opts.marginUnit;\n      let right = this.opts.marginRight + this.opts.marginUnit;\n      let left = this.opts.marginLeft + this.opts.marginUnit;\n      let content = `${prefix} > .grid-stack-item-content`;\n      let placeholder = `.${this._styleSheetClass} > .grid-stack-placeholder > .placeholder-content`;\n      utils_1.Utils.addCSSRule(this._styles, content, `top: ${top}; right: ${right}; bottom: ${bottom}; left: ${left};`);\n      utils_1.Utils.addCSSRule(this._styles, placeholder, `top: ${top}; right: ${right}; bottom: ${bottom}; left: ${left};`);\n      // resize handles offset (to match margin)\n      utils_1.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-ne`, `right: ${right}`);\n      utils_1.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-e`, `right: ${right}`);\n      utils_1.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-se`, `right: ${right}; bottom: ${bottom}`);\n      utils_1.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-nw`, `left: ${left}`);\n      utils_1.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-w`, `left: ${left}`);\n      utils_1.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-sw`, `left: ${left}; bottom: ${bottom}`);\n    }\n    // now update the height specific fields\n    maxH = maxH || this._styles._max;\n    if (maxH > this._styles._max) {\n      let getHeight = rows => cellHeight * rows + cellHeightUnit;\n      for (let i = this._styles._max + 1; i <= maxH; i++) {\n        // start at 1\n        let h = getHeight(i);\n        utils_1.Utils.addCSSRule(this._styles, `${prefix}[gs-y=\"${i - 1}\"]`, `top: ${getHeight(i - 1)}`); // start at 0\n        utils_1.Utils.addCSSRule(this._styles, `${prefix}[gs-h=\"${i}\"]`, `height: ${h}`);\n        utils_1.Utils.addCSSRule(this._styles, `${prefix}[gs-min-h=\"${i}\"]`, `min-height: ${h}`);\n        utils_1.Utils.addCSSRule(this._styles, `${prefix}[gs-max-h=\"${i}\"]`, `max-height: ${h}`);\n      }\n      this._styles._max = maxH;\n    }\n    return this;\n  }\n  /** @internal */\n  _updateContainerHeight() {\n    if (!this.engine || this.engine.batchMode) return this;\n    let row = this.getRow() + this._extraDragRow; // checks for minRow already\n    // check for css min height\n    // Note: we don't handle %,rem correctly so comment out, beside we don't need need to create un-necessary\n    // rows as the CSS will make us bigger than our set height if needed... not sure why we had this.\n    // let cssMinHeight = parseInt(getComputedStyle(this.el)['min-height']);\n    // if (cssMinHeight > 0) {\n    //   let minRow = Math.round(cssMinHeight / this.getCellHeight(true));\n    //   if (row < minRow) {\n    //     row = minRow;\n    //   }\n    // }\n    this.el.setAttribute('gs-current-row', String(row));\n    if (row === 0) {\n      this.el.style.removeProperty('min-height');\n      return this;\n    }\n    let cellHeight = this.opts.cellHeight;\n    let unit = this.opts.cellHeightUnit;\n    if (!cellHeight) return this;\n    this.el.style.minHeight = row * cellHeight + unit;\n    return this;\n  }\n  /** @internal */\n  _prepareElement(el) {\n    let triggerAddEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let node = arguments.length > 2 ? arguments[2] : undefined;\n    el.classList.add(this.opts.itemClass);\n    node = node || this._readAttr(el);\n    el.gridstackNode = node;\n    node.el = el;\n    node.grid = this;\n    let copy = Object.assign({}, node);\n    node = this.engine.addNode(node, triggerAddEvent);\n    // write node attr back in case there was collision or we have to fix bad values during addNode()\n    if (!utils_1.Utils.same(node, copy)) {\n      this._writeAttr(el, node);\n    }\n    this._prepareDragDropByNode(node);\n    return this;\n  }\n  /** @internal call to write position x,y,w,h attributes back to element */\n  _writePosAttr(el, n) {\n    if (n.x !== undefined && n.x !== null) {\n      el.setAttribute('gs-x', String(n.x));\n    }\n    if (n.y !== undefined && n.y !== null) {\n      el.setAttribute('gs-y', String(n.y));\n    }\n    if (n.w) {\n      el.setAttribute('gs-w', String(n.w));\n    }\n    if (n.h) {\n      el.setAttribute('gs-h', String(n.h));\n    }\n    return this;\n  }\n  /** @internal call to write any default attributes back to element */\n  _writeAttr(el, node) {\n    if (!node) return this;\n    this._writePosAttr(el, node);\n    let attrs /*: GridStackWidget but strings */ = {\n      autoPosition: 'gs-auto-position',\n      minW: 'gs-min-w',\n      minH: 'gs-min-h',\n      maxW: 'gs-max-w',\n      maxH: 'gs-max-h',\n      noResize: 'gs-no-resize',\n      noMove: 'gs-no-move',\n      locked: 'gs-locked',\n      id: 'gs-id'\n    };\n    for (const key in attrs) {\n      if (node[key]) {\n        // 0 is valid for x,y only but done above already and not in list anyway\n        el.setAttribute(attrs[key], String(node[key]));\n      } else {\n        el.removeAttribute(attrs[key]);\n      }\n    }\n    return this;\n  }\n  /** @internal call to read any default attributes from element */\n  _readAttr(el) {\n    let node = {};\n    node.x = utils_1.Utils.toNumber(el.getAttribute('gs-x'));\n    node.y = utils_1.Utils.toNumber(el.getAttribute('gs-y'));\n    node.w = utils_1.Utils.toNumber(el.getAttribute('gs-w'));\n    node.h = utils_1.Utils.toNumber(el.getAttribute('gs-h'));\n    node.maxW = utils_1.Utils.toNumber(el.getAttribute('gs-max-w'));\n    node.minW = utils_1.Utils.toNumber(el.getAttribute('gs-min-w'));\n    node.maxH = utils_1.Utils.toNumber(el.getAttribute('gs-max-h'));\n    node.minH = utils_1.Utils.toNumber(el.getAttribute('gs-min-h'));\n    node.autoPosition = utils_1.Utils.toBool(el.getAttribute('gs-auto-position'));\n    node.noResize = utils_1.Utils.toBool(el.getAttribute('gs-no-resize'));\n    node.noMove = utils_1.Utils.toBool(el.getAttribute('gs-no-move'));\n    node.locked = utils_1.Utils.toBool(el.getAttribute('gs-locked'));\n    node.id = el.getAttribute('gs-id');\n    // remove any key not found (null or false which is default)\n    for (const key in node) {\n      if (!node.hasOwnProperty(key)) return;\n      if (!node[key] && node[key] !== 0) {\n        // 0 can be valid value (x,y only really)\n        delete node[key];\n      }\n    }\n    return node;\n  }\n  /** @internal */\n  _setStaticClass() {\n    let classes = ['grid-stack-static'];\n    if (this.opts.staticGrid) {\n      this.el.classList.add(...classes);\n      this.el.setAttribute('gs-static', 'true');\n    } else {\n      this.el.classList.remove(...classes);\n      this.el.removeAttribute('gs-static');\n    }\n    return this;\n  }\n  /**\r\n   * called when we are being resized by the window - check if the one Column Mode needs to be turned on/off\r\n   * and remember the prev columns we used, or get our count from parent, as well as check for auto cell height (square)\r\n   */\n  onParentResize() {\n    if (!this.el || !this.el.clientWidth) return; // return if we're gone or no size yet (will get called again)\n    let changedColumn = false;\n    // see if we're nested and take our column count from our parent....\n    if (this._autoColumn && this.parentGridItem) {\n      if (this.opts.column !== this.parentGridItem.w) {\n        changedColumn = true;\n        this.column(this.parentGridItem.w, 'none');\n      }\n    } else {\n      // else check for 1 column in/out behavior\n      let oneColumn = !this.opts.disableOneColumnMode && this.el.clientWidth <= this.opts.oneColumnSize;\n      if (this.opts.column === 1 !== oneColumn) {\n        changedColumn = true;\n        if (this.opts.animate) {\n          this.setAnimation(false);\n        } // 1 <-> 12 is too radical, turn off animation\n        this.column(oneColumn ? 1 : this._prevColumn);\n        if (this.opts.animate) {\n          this.setAnimation(true);\n        }\n      }\n    }\n    // make the cells content square again\n    if (this._isAutoCellHeight) {\n      if (!changedColumn && this.opts.cellHeightThrottle) {\n        if (!this._cellHeightThrottle) {\n          this._cellHeightThrottle = utils_1.Utils.throttle(() => this.cellHeight(), this.opts.cellHeightThrottle);\n        }\n        this._cellHeightThrottle();\n      } else {\n        // immediate update if we've changed column count or have no threshold\n        this.cellHeight();\n      }\n    }\n    // finally update any nested grids\n    this.engine.nodes.forEach(n => {\n      if (n.subGrid) {\n        n.subGrid.onParentResize();\n      }\n    });\n    return this;\n  }\n  /** add or remove the window size event handler */\n  _updateWindowResizeEvent() {\n    let forceRemove = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    // only add event if we're not nested (parent will call us) and we're auto sizing cells or supporting oneColumn (i.e. doing work)\n    const workTodo = (this._isAutoCellHeight || !this.opts.disableOneColumnMode) && !this.parentGridItem;\n    if (!forceRemove && workTodo && !this._windowResizeBind) {\n      this._windowResizeBind = this.onParentResize.bind(this); // so we can properly remove later\n      window.addEventListener('resize', this._windowResizeBind);\n    } else if ((forceRemove || !workTodo) && this._windowResizeBind) {\n      window.removeEventListener('resize', this._windowResizeBind);\n      delete this._windowResizeBind; // remove link to us so we can free\n    }\n\n    return this;\n  }\n  /** @internal convert a potential selector into actual element */\n  static getElement() {\n    let els = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '.grid-stack-item';\n    return utils_1.Utils.getElement(els);\n  }\n  /** @internal */\n  static getElements() {\n    let els = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '.grid-stack-item';\n    return utils_1.Utils.getElements(els);\n  }\n  /** @internal */\n  static getGridElement(els) {\n    return GridStack.getElement(els);\n  }\n  /** @internal */\n  static getGridElements(els) {\n    return utils_1.Utils.getElements(els);\n  }\n  /** @internal initialize margin top/bottom/left/right and units */\n  _initMargin() {\n    let data;\n    let margin = 0;\n    // support passing multiple values like CSS (ex: '5px 10px 0 20px')\n    let margins = [];\n    if (typeof this.opts.margin === 'string') {\n      margins = this.opts.margin.split(' ');\n    }\n    if (margins.length === 2) {\n      // top/bot, left/right like CSS\n      this.opts.marginTop = this.opts.marginBottom = margins[0];\n      this.opts.marginLeft = this.opts.marginRight = margins[1];\n    } else if (margins.length === 4) {\n      // Clockwise like CSS\n      this.opts.marginTop = margins[0];\n      this.opts.marginRight = margins[1];\n      this.opts.marginBottom = margins[2];\n      this.opts.marginLeft = margins[3];\n    } else {\n      data = utils_1.Utils.parseHeight(this.opts.margin);\n      this.opts.marginUnit = data.unit;\n      margin = this.opts.margin = data.h;\n    }\n    // see if top/bottom/left/right need to be set as well\n    if (this.opts.marginTop === undefined) {\n      this.opts.marginTop = margin;\n    } else {\n      data = utils_1.Utils.parseHeight(this.opts.marginTop);\n      this.opts.marginTop = data.h;\n      delete this.opts.margin;\n    }\n    if (this.opts.marginBottom === undefined) {\n      this.opts.marginBottom = margin;\n    } else {\n      data = utils_1.Utils.parseHeight(this.opts.marginBottom);\n      this.opts.marginBottom = data.h;\n      delete this.opts.margin;\n    }\n    if (this.opts.marginRight === undefined) {\n      this.opts.marginRight = margin;\n    } else {\n      data = utils_1.Utils.parseHeight(this.opts.marginRight);\n      this.opts.marginRight = data.h;\n      delete this.opts.margin;\n    }\n    if (this.opts.marginLeft === undefined) {\n      this.opts.marginLeft = margin;\n    } else {\n      data = utils_1.Utils.parseHeight(this.opts.marginLeft);\n      this.opts.marginLeft = data.h;\n      delete this.opts.margin;\n    }\n    this.opts.marginUnit = data.unit; // in case side were spelled out, use those units instead...\n    if (this.opts.marginTop === this.opts.marginBottom && this.opts.marginLeft === this.opts.marginRight && this.opts.marginTop === this.opts.marginRight) {\n      this.opts.margin = this.opts.marginTop; // makes it easier to check for no-ops in setMargin()\n    }\n\n    return this;\n  }\n  /* ===========================================================================================\r\n   * drag&drop methods that used to be stubbed out and implemented in dd-gridstack.ts\r\n   * but caused loading issues in prod - see https://github.com/gridstack/gridstack.js/issues/2039\r\n   * ===========================================================================================\r\n   */\n  /** get the global (but static to this code) DD implementation */\n  static getDD() {\n    return dd;\n  }\n  /**\r\n   * call to setup dragging in from the outside (say toolbar), by specifying the class selection and options.\r\n   * Called during GridStack.init() as options, but can also be called directly (last param are used) in case the toolbar\r\n   * is dynamically create and needs to be set later.\r\n   * @param dragIn string selector (ex: '.sidebar .grid-stack-item')\r\n   * @param dragInOptions options - see DDDragInOpt. (default: {handle: '.grid-stack-item-content', appendTo: 'body'}\r\n   **/\n  static setupDragIn(dragIn, dragInOptions) {\n    if ((dragInOptions === null || dragInOptions === void 0 ? void 0 : dragInOptions.pause) !== undefined) {\n      dd_manager_1.DDManager.pauseDrag = dragInOptions.pause;\n    }\n    if (typeof dragIn === 'string') {\n      dragInOptions = Object.assign(Object.assign({}, types_1.dragInDefaultOptions), dragInOptions || {});\n      utils_1.Utils.getElements(dragIn).forEach(el => {\n        if (!dd.isDraggable(el)) dd.dragIn(el, dragInOptions);\n      });\n    }\n  }\n  /**\r\n   * Enables/Disables dragging by the user of specific grid element. If you want all items, and have it affect future items, use enableMove() instead. No-op for static grids.\r\n   * IF you are looking to prevent an item from moving (due to being pushed around by another during collision) use locked property instead.\r\n   * @param els widget or selector to modify.\r\n   * @param val if true widget will be draggable.\r\n   */\n  movable(els, val) {\n    if (this.opts.staticGrid) return this; // can't move a static grid!\n    GridStack.getElements(els).forEach(el => {\n      let node = el.gridstackNode;\n      if (!node) return;\n      if (val) delete node.noMove;else node.noMove = true;\n      this._prepareDragDropByNode(node); // init DD if need be, and adjust\n    });\n\n    return this;\n  }\n  /**\r\n   * Enables/Disables user resizing of specific grid element. If you want all items, and have it affect future items, use enableResize() instead. No-op for static grids.\r\n   * @param els  widget or selector to modify\r\n   * @param val  if true widget will be resizable.\r\n   */\n  resizable(els, val) {\n    if (this.opts.staticGrid) return this; // can't resize a static grid!\n    GridStack.getElements(els).forEach(el => {\n      let node = el.gridstackNode;\n      if (!node) return;\n      if (val) delete node.noResize;else node.noResize = true;\n      this._prepareDragDropByNode(node); // init DD if need be, and adjust\n    });\n\n    return this;\n  }\n  /**\r\n   * Temporarily disables widgets moving/resizing.\r\n   * If you want a more permanent way (which freezes up resources) use `setStatic(true)` instead.\r\n   * Note: no-op for static grid\r\n   * This is a shortcut for:\r\n   * @example\r\n   *  grid.enableMove(false);\r\n   *  grid.enableResize(false);\r\n   * @param recurse true (default) if sub-grids also get updated\r\n   */\n  disable() {\n    let recurse = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (this.opts.staticGrid) return;\n    this.enableMove(false, recurse);\n    this.enableResize(false, recurse); // @ts-ignore\n    this._triggerEvent('disable');\n    return this;\n  }\n  /**\r\n   * Re-enables widgets moving/resizing - see disable().\r\n   * Note: no-op for static grid.\r\n   * This is a shortcut for:\r\n   * @example\r\n   *  grid.enableMove(true);\r\n   *  grid.enableResize(true);\r\n   * @param recurse true (default) if sub-grids also get updated\r\n   */\n  enable() {\n    let recurse = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (this.opts.staticGrid) return;\n    this.enableMove(true, recurse);\n    this.enableResize(true, recurse); // @ts-ignore\n    this._triggerEvent('enable');\n    return this;\n  }\n  /**\r\n   * Enables/disables widget moving. No-op for static grids.\r\n   * @param recurse true (default) if sub-grids also get updated\r\n   */\n  enableMove(doEnable) {\n    let recurse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (this.opts.staticGrid) return this; // can't move a static grid!\n    this.opts.disableDrag = !doEnable; // FIRST before we update children as grid overrides #1658\n    this.engine.nodes.forEach(n => {\n      this.movable(n.el, doEnable);\n      if (n.subGrid && recurse) n.subGrid.enableMove(doEnable, recurse);\n    });\n    return this;\n  }\n  /**\r\n   * Enables/disables widget resizing. No-op for static grids.\r\n   * @param recurse true (default) if sub-grids also get updated\r\n   */\n  enableResize(doEnable) {\n    let recurse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (this.opts.staticGrid) return this; // can't size a static grid!\n    this.opts.disableResize = !doEnable; // FIRST before we update children as grid overrides #1658\n    this.engine.nodes.forEach(n => {\n      this.resizable(n.el, doEnable);\n      if (n.subGrid && recurse) n.subGrid.enableResize(doEnable, recurse);\n    });\n    return this;\n  }\n  /** @internal removes any drag&drop present (called during destroy) */\n  _removeDD(el) {\n    dd.draggable(el, 'destroy').resizable(el, 'destroy');\n    if (el.gridstackNode) {\n      delete el.gridstackNode._initDD; // reset our DD init flag\n    }\n\n    delete el.ddElement;\n    return this;\n  }\n  /** @internal called to add drag over to support widgets being added externally */\n  _setupAcceptWidget() {\n    // check if we need to disable things\n    if (this.opts.staticGrid || !this.opts.acceptWidgets && !this.opts.removable) {\n      dd.droppable(this.el, 'destroy');\n      return this;\n    }\n    // vars shared across all methods\n    let cellHeight, cellWidth;\n    let onDrag = (event, el, helper) => {\n      let node = el.gridstackNode;\n      if (!node) return;\n      helper = helper || el;\n      let parent = this.el.getBoundingClientRect();\n      let {\n        top,\n        left\n      } = helper.getBoundingClientRect();\n      left -= parent.left;\n      top -= parent.top;\n      let ui = {\n        position: {\n          top,\n          left\n        }\n      };\n      if (node._temporaryRemoved) {\n        node.x = Math.max(0, Math.round(left / cellWidth));\n        node.y = Math.max(0, Math.round(top / cellHeight));\n        delete node.autoPosition;\n        this.engine.nodeBoundFix(node);\n        // don't accept *initial* location if doesn't fit #1419 (locked drop region, or can't grow), but maybe try if it will go somewhere\n        if (!this.engine.willItFit(node)) {\n          node.autoPosition = true; // ignore x,y and try for any slot...\n          if (!this.engine.willItFit(node)) {\n            dd.off(el, 'drag'); // stop calling us\n            return; // full grid or can't grow\n          }\n\n          if (node._willFitPos) {\n            // use the auto position instead #1687\n            utils_1.Utils.copyPos(node, node._willFitPos);\n            delete node._willFitPos;\n          }\n        }\n        // re-use the existing node dragging method\n        this._onStartMoving(helper, event, ui, node, cellWidth, cellHeight);\n      } else {\n        // re-use the existing node dragging that does so much of the collision detection\n        this._dragOrResize(helper, event, ui, node, cellWidth, cellHeight);\n      }\n    };\n    dd.droppable(this.el, {\n      accept: el => {\n        let node = el.gridstackNode;\n        // set accept drop to true on ourself (which we ignore) so we don't get \"can't drop\" icon in HTML5 mode while moving\n        if ((node === null || node === void 0 ? void 0 : node.grid) === this) return true;\n        if (!this.opts.acceptWidgets) return false;\n        // check for accept method or class matching\n        let canAccept = true;\n        if (typeof this.opts.acceptWidgets === 'function') {\n          canAccept = this.opts.acceptWidgets(el);\n        } else {\n          let selector = this.opts.acceptWidgets === true ? '.grid-stack-item' : this.opts.acceptWidgets;\n          canAccept = el.matches(selector);\n        }\n        // finally check to make sure we actually have space left #1571\n        if (canAccept && node && this.opts.maxRow) {\n          let n = {\n            w: node.w,\n            h: node.h,\n            minW: node.minW,\n            minH: node.minH\n          }; // only width/height matters and autoPosition\n          canAccept = this.engine.willItFit(n);\n        }\n        return canAccept;\n      }\n    })\n    /**\r\n     * entering our grid area\r\n     */.on(this.el, 'dropover', (event, el, helper) => {\n      // console.log(`over ${this.el.gridstack.opts.id} ${count++}`); // TEST\n      let node = el.gridstackNode;\n      // ignore drop enter on ourself (unless we temporarily removed) which happens on a simple drag of our item\n      if ((node === null || node === void 0 ? void 0 : node.grid) === this && !node._temporaryRemoved) {\n        // delete node._added; // reset this to track placeholder again in case we were over other grid #1484 (dropout doesn't always clear)\n        return false; // prevent parent from receiving msg (which may be a grid as well)\n      }\n      // fix #1578 when dragging fast, we may not get a leave on the previous grid so force one now\n      if ((node === null || node === void 0 ? void 0 : node.grid) && node.grid !== this && !node._temporaryRemoved) {\n        // console.log('dropover without leave'); // TEST\n        let otherGrid = node.grid;\n        otherGrid._leave(el, helper);\n      }\n      // cache cell dimensions (which don't change), position can animate if we removed an item in otherGrid that affects us...\n      cellWidth = this.cellWidth();\n      cellHeight = this.getCellHeight(true);\n      // load any element attributes if we don't have a node\n      if (!node) {\n        // @ts-ignore private read only on ourself\n        node = this._readAttr(el);\n      }\n      if (!node.grid) {\n        node._isExternal = true;\n        el.gridstackNode = node;\n      }\n      // calculate the grid size based on element outer size\n      helper = helper || el;\n      let w = node.w || Math.round(helper.offsetWidth / cellWidth) || 1;\n      let h = node.h || Math.round(helper.offsetHeight / cellHeight) || 1;\n      // if the item came from another grid, make a copy and save the original info in case we go back there\n      if (node.grid && node.grid !== this) {\n        // copy the node original values (min/max/id/etc...) but override width/height/other flags which are this grid specific\n        // console.log('dropover cloning node'); // TEST\n        if (!el._gridstackNodeOrig) el._gridstackNodeOrig = node; // shouldn't have multiple nested!\n        el.gridstackNode = node = Object.assign(Object.assign({}, node), {\n          w,\n          h,\n          grid: this\n        });\n        this.engine.cleanupNode(node).nodeBoundFix(node);\n        // restore some internal fields we need after clearing them all\n        node._initDD = node._isExternal =\n        // DOM needs to be re-parented on a drop\n        node._temporaryRemoved = true; // so it can be inserted onDrag below\n      } else {\n        node.w = w;\n        node.h = h;\n        node._temporaryRemoved = true; // so we can insert it\n      }\n      // clear any marked for complete removal (Note: don't check _isAboutToRemove as that is cleared above - just do it)\n      this._itemRemoving(node.el, false);\n      dd.on(el, 'drag', onDrag);\n      // make sure this is called at least once when going fast #1578\n      onDrag(event, el, helper);\n      return false; // prevent parent from receiving msg (which may be a grid as well)\n    })\n    /**\r\n     * Leaving our grid area...\r\n     */.on(this.el, 'dropout', (event, el, helper) => {\n      // console.log(`out ${this.el.gridstack.opts.id} ${count++}`); // TEST\n      let node = el.gridstackNode;\n      if (!node) return false;\n      // fix #1578 when dragging fast, we might get leave after other grid gets enter (which calls us to clean)\n      // so skip this one if we're not the active grid really..\n      if (!node.grid || node.grid === this) {\n        this._leave(el, helper);\n        // if we were created as temporary nested grid, go back to before state\n        if (this._isTemp) {\n          this.removeAsSubGrid(node);\n        }\n      }\n      return false; // prevent parent from receiving msg (which may be grid as well)\n    })\n    /**\r\n     * end - releasing the mouse\r\n     */.on(this.el, 'drop', (event, el, helper) => {\n      var _a, _b;\n      let node = el.gridstackNode;\n      // ignore drop on ourself from ourself that didn't come from the outside - dragend will handle the simple move instead\n      if ((node === null || node === void 0 ? void 0 : node.grid) === this && !node._isExternal) return false;\n      let wasAdded = !!this.placeholder.parentElement; // skip items not actually added to us because of constrains, but do cleanup #1419\n      this.placeholder.remove();\n      // notify previous grid of removal\n      // console.log('drop delete _gridstackNodeOrig') // TEST\n      let origNode = el._gridstackNodeOrig;\n      delete el._gridstackNodeOrig;\n      if (wasAdded && (origNode === null || origNode === void 0 ? void 0 : origNode.grid) && origNode.grid !== this) {\n        let oGrid = origNode.grid;\n        oGrid.engine.removedNodes.push(origNode);\n        oGrid._triggerRemoveEvent()._triggerChangeEvent();\n        // if it's an empty sub-grid that got auto-created, nuke it\n        if (oGrid.parentGridItem && !oGrid.engine.nodes.length && oGrid.opts.subGridDynamic) {\n          oGrid.removeAsSubGrid();\n        }\n      }\n      if (!node) return false;\n      // use existing placeholder node as it's already in our list with drop location\n      if (wasAdded) {\n        this.engine.cleanupNode(node); // removes all internal _xyz values\n        node.grid = this;\n      }\n      dd.off(el, 'drag');\n      // if we made a copy ('helper' which is temp) of the original node then insert a copy, else we move the original node (#1102)\n      // as the helper will be nuked by jquery-ui otherwise. TODO: update old code path\n      if (helper !== el) {\n        helper.remove();\n        el.gridstackNode = origNode; // original item (left behind) is re-stored to pre dragging as the node now has drop info\n        if (wasAdded) {\n          el = el.cloneNode(true);\n        }\n      } else {\n        el.remove(); // reduce flicker as we change depth here, and size further down\n        this._removeDD(el);\n      }\n      if (!wasAdded) return false;\n      el.gridstackNode = node;\n      node.el = el;\n      let subGrid = (_b = (_a = node.subGrid) === null || _a === void 0 ? void 0 : _a.el) === null || _b === void 0 ? void 0 : _b.gridstack; // set when actual sub-grid present\n      // @ts-ignore\n      utils_1.Utils.copyPos(node, this._readAttr(this.placeholder)); // placeholder values as moving VERY fast can throw things off #1578\n      utils_1.Utils.removePositioningStyles(el); // @ts-ignore\n      this._writeAttr(el, node);\n      el.classList.add(types_1.gridDefaults.itemClass, this.opts.itemClass);\n      this.el.appendChild(el); // @ts-ignore // TODO: now would be ideal time to _removeHelperStyle() overriding floating styles (native only)\n      if (subGrid) {\n        subGrid.parentGridItem = node;\n        if (!subGrid.opts.styleInHead) subGrid._updateStyles(true); // re-create sub-grid styles now that we've moved\n      }\n\n      this._updateContainerHeight();\n      this.engine.addedNodes.push(node); // @ts-ignore\n      this._triggerAddEvent(); // @ts-ignore\n      this._triggerChangeEvent();\n      this.engine.endUpdate();\n      if (this._gsEventHandler['dropped']) {\n        this._gsEventHandler['dropped'](Object.assign(Object.assign({}, event), {\n          type: 'dropped'\n        }), origNode && origNode.grid ? origNode : undefined, node);\n      }\n      // wait till we return out of the drag callback to set the new drag&resize handler or they may get messed up\n      window.setTimeout(() => {\n        // IFF we are still there (some application will use as placeholder and insert their real widget instead and better call makeWidget())\n        if (node.el && node.el.parentElement) {\n          this._prepareDragDropByNode(node);\n        } else {\n          this.engine.removeNode(node);\n        }\n        delete node.grid._isTemp;\n      });\n      return false; // prevent parent from receiving msg (which may be grid as well)\n    });\n\n    return this;\n  }\n  /** @internal mark item for removal */\n  _itemRemoving(el, remove) {\n    let node = el ? el.gridstackNode : undefined;\n    if (!node || !node.grid) return;\n    remove ? node._isAboutToRemove = true : delete node._isAboutToRemove;\n    remove ? el.classList.add('grid-stack-item-removing') : el.classList.remove('grid-stack-item-removing');\n  }\n  /** @internal called to setup a trash drop zone if the user specifies it */\n  _setupRemoveDrop() {\n    if (!this.opts.staticGrid && typeof this.opts.removable === 'string') {\n      let trashEl = document.querySelector(this.opts.removable);\n      if (!trashEl) return this;\n      // only register ONE drop-over/dropout callback for the 'trash', and it will\n      // update the passed in item and parent grid because the 'trash' is a shared resource anyway,\n      // and Native DD only has 1 event CB (having a list and technically a per grid removableOptions complicates things greatly)\n      if (!dd.isDroppable(trashEl)) {\n        dd.droppable(trashEl, this.opts.removableOptions).on(trashEl, 'dropover', (event, el) => this._itemRemoving(el, true)).on(trashEl, 'dropout', (event, el) => this._itemRemoving(el, false));\n      }\n    }\n    return this;\n  }\n  /** @internal prepares the element for drag&drop **/\n  _prepareDragDropByNode(node) {\n    let el = node.el;\n    const noMove = node.noMove || this.opts.disableDrag;\n    const noResize = node.noResize || this.opts.disableResize;\n    // check for disabled grid first\n    if (this.opts.staticGrid || noMove && noResize) {\n      if (node._initDD) {\n        this._removeDD(el); // nukes everything instead of just disable, will add some styles back next\n        delete node._initDD;\n      }\n      el.classList.add('ui-draggable-disabled', 'ui-resizable-disabled'); // add styles one might depend on #1435\n      return this;\n    }\n    if (!node._initDD) {\n      // variables used/cashed between the 3 start/move/end methods, in addition to node passed above\n      let cellWidth;\n      let cellHeight;\n      /** called when item starts moving/resizing */\n      let onStartMoving = (event, ui) => {\n        // trigger any 'dragstart' / 'resizestart' manually\n        if (this._gsEventHandler[event.type]) {\n          this._gsEventHandler[event.type](event, event.target);\n        }\n        cellWidth = this.cellWidth();\n        cellHeight = this.getCellHeight(true); // force pixels for calculations\n        this._onStartMoving(el, event, ui, node, cellWidth, cellHeight);\n      };\n      /** called when item is being dragged/resized */\n      let dragOrResize = (event, ui) => {\n        this._dragOrResize(el, event, ui, node, cellWidth, cellHeight);\n      };\n      /** called when the item stops moving/resizing */\n      let onEndMoving = event => {\n        this.placeholder.remove();\n        delete node._moving;\n        delete node._event;\n        delete node._lastTried;\n        // if the item has moved to another grid, we're done here\n        let target = event.target;\n        if (!target.gridstackNode || target.gridstackNode.grid !== this) return;\n        node.el = target;\n        if (node._isAboutToRemove) {\n          let gridToNotify = el.gridstackNode.grid;\n          if (gridToNotify._gsEventHandler[event.type]) {\n            gridToNotify._gsEventHandler[event.type](event, target);\n          }\n          this._removeDD(el);\n          gridToNotify.engine.removedNodes.push(node);\n          gridToNotify._triggerRemoveEvent();\n          // break circular links and remove DOM\n          delete el.gridstackNode;\n          delete node.el;\n          el.remove();\n        } else {\n          utils_1.Utils.removePositioningStyles(target);\n          if (node._temporaryRemoved) {\n            // got removed - restore item back to before dragging position\n            utils_1.Utils.copyPos(node, node._orig); // @ts-ignore\n            this._writePosAttr(target, node);\n            this.engine.addNode(node);\n          } else {\n            // move to new placeholder location\n            this._writePosAttr(target, node);\n          }\n          if (this._gsEventHandler[event.type]) {\n            this._gsEventHandler[event.type](event, target);\n          }\n        }\n        // @ts-ignore\n        this._extraDragRow = 0; // @ts-ignore\n        this._updateContainerHeight(); // @ts-ignore\n        this._triggerChangeEvent();\n        this.engine.endUpdate();\n      };\n      dd.draggable(el, {\n        start: onStartMoving,\n        stop: onEndMoving,\n        drag: dragOrResize\n      }).resizable(el, {\n        start: onStartMoving,\n        stop: onEndMoving,\n        resize: dragOrResize\n      });\n      node._initDD = true; // we've set DD support now\n    }\n    // finally fine tune move vs resize by disabling any part...\n    dd.draggable(el, noMove ? 'disable' : 'enable').resizable(el, noResize ? 'disable' : 'enable');\n    return this;\n  }\n  /** @internal handles actual drag/resize start **/\n  _onStartMoving(el, event, ui, node, cellWidth, cellHeight) {\n    this.engine.cleanNodes().beginUpdate(node);\n    // @ts-ignore\n    this._writePosAttr(this.placeholder, node);\n    this.el.appendChild(this.placeholder);\n    // console.log('_onStartMoving placeholder') // TEST\n    node.el = this.placeholder;\n    node._lastUiPosition = ui.position;\n    node._prevYPix = ui.position.top;\n    node._moving = event.type === 'dragstart'; // 'dropover' are not initially moving so they can go exactly where they enter (will push stuff out of the way)\n    delete node._lastTried;\n    if (event.type === 'dropover' && node._temporaryRemoved) {\n      // console.log('engine.addNode x=' + node.x); // TEST\n      this.engine.addNode(node); // will add, fix collisions, update attr and clear _temporaryRemoved\n      node._moving = true; // AFTER, mark as moving object (wanted fix location before)\n    }\n    // set the min/max resize info\n    this.engine.cacheRects(cellWidth, cellHeight, this.opts.marginTop, this.opts.marginRight, this.opts.marginBottom, this.opts.marginLeft);\n    if (event.type === 'resizestart') {\n      dd.resizable(el, 'option', 'minWidth', cellWidth * (node.minW || 1)).resizable(el, 'option', 'minHeight', cellHeight * (node.minH || 1));\n      if (node.maxW) {\n        dd.resizable(el, 'option', 'maxWidth', cellWidth * node.maxW);\n      }\n      if (node.maxH) {\n        dd.resizable(el, 'option', 'maxHeight', cellHeight * node.maxH);\n      }\n    }\n  }\n  /** @internal handles actual drag/resize **/\n  _dragOrResize(el, event, ui, node, cellWidth, cellHeight) {\n    let p = Object.assign({}, node._orig); // could be undefined (_isExternal) which is ok (drag only set x,y and w,h will default to node value)\n    let resizing;\n    let mLeft = this.opts.marginLeft,\n      mRight = this.opts.marginRight,\n      mTop = this.opts.marginTop,\n      mBottom = this.opts.marginBottom;\n    // if margins (which are used to pass mid point by) are large relative to cell height/width, reduce them down #1855\n    let mHeight = Math.round(cellHeight * 0.1),\n      mWidth = Math.round(cellWidth * 0.1);\n    mLeft = Math.min(mLeft, mWidth);\n    mRight = Math.min(mRight, mWidth);\n    mTop = Math.min(mTop, mHeight);\n    mBottom = Math.min(mBottom, mHeight);\n    if (event.type === 'drag') {\n      if (node._temporaryRemoved) return; // handled by dropover\n      let distance = ui.position.top - node._prevYPix;\n      node._prevYPix = ui.position.top;\n      if (this.opts.draggable.scroll !== false) {\n        utils_1.Utils.updateScrollPosition(el, ui.position, distance);\n      }\n      // get new position taking into account the margin in the direction we are moving! (need to pass mid point by margin)\n      let left = ui.position.left + (ui.position.left > node._lastUiPosition.left ? -mRight : mLeft);\n      let top = ui.position.top + (ui.position.top > node._lastUiPosition.top ? -mBottom : mTop);\n      p.x = Math.round(left / cellWidth);\n      p.y = Math.round(top / cellHeight);\n      // @ts-ignore// if we're at the bottom hitting something else, grow the grid so cursor doesn't leave when trying to place below others\n      let prev = this._extraDragRow;\n      if (this.engine.collide(node, p)) {\n        let row = this.getRow();\n        let extra = Math.max(0, p.y + node.h - row);\n        if (this.opts.maxRow && row + extra > this.opts.maxRow) {\n          extra = Math.max(0, this.opts.maxRow - row);\n        } // @ts-ignore\n        this._extraDragRow = extra; // @ts-ignore\n      } else this._extraDragRow = 0; // @ts-ignore\n      if (this._extraDragRow !== prev) this._updateContainerHeight();\n      if (node.x === p.x && node.y === p.y) return; // skip same\n      // DON'T skip one we tried as we might have failed because of coverage <50% before\n      // if (node._lastTried && node._lastTried.x === x && node._lastTried.y === y) return;\n    } else if (event.type === 'resize') {\n      if (p.x < 0) return;\n      // Scrolling page if needed\n      utils_1.Utils.updateScrollResize(event, el, cellHeight);\n      // get new size\n      p.w = Math.round((ui.size.width - mLeft) / cellWidth);\n      p.h = Math.round((ui.size.height - mTop) / cellHeight);\n      if (node.w === p.w && node.h === p.h) return;\n      if (node._lastTried && node._lastTried.w === p.w && node._lastTried.h === p.h) return; // skip one we tried (but failed)\n      // if we size on left/top side this might move us, so get possible new position as well\n      let left = ui.position.left + mLeft;\n      let top = ui.position.top + mTop;\n      p.x = Math.round(left / cellWidth);\n      p.y = Math.round(top / cellHeight);\n      resizing = true;\n    }\n    node._event = event;\n    node._lastTried = p; // set as last tried (will nuke if we go there)\n    let rect = {\n      x: ui.position.left + mLeft,\n      y: ui.position.top + mTop,\n      w: (ui.size ? ui.size.width : node.w * cellWidth) - mLeft - mRight,\n      h: (ui.size ? ui.size.height : node.h * cellHeight) - mTop - mBottom\n    };\n    if (this.engine.moveNodeCheck(node, Object.assign(Object.assign({}, p), {\n      cellWidth,\n      cellHeight,\n      rect,\n      resizing\n    }))) {\n      node._lastUiPosition = ui.position;\n      this.engine.cacheRects(cellWidth, cellHeight, mTop, mRight, mBottom, mLeft);\n      delete node._skipDown;\n      if (resizing && node.subGrid) {\n        node.subGrid.onParentResize();\n      } // @ts-ignore\n      this._extraDragRow = 0; // @ts-ignore\n      this._updateContainerHeight();\n      let target = event.target; // @ts-ignore\n      this._writePosAttr(target, node);\n      if (this._gsEventHandler[event.type]) {\n        this._gsEventHandler[event.type](event, target);\n      }\n    }\n  }\n  /** @internal called when item leaving our area by either cursor dropout event\r\n   * or shape is outside our boundaries. remove it from us, and mark temporary if this was\r\n   * our item to start with else restore prev node values from prev grid it came from.\r\n   **/\n  _leave(el, helper) {\n    let node = el.gridstackNode;\n    if (!node) return;\n    dd.off(el, 'drag'); // no need to track while being outside\n    // this gets called when cursor leaves and shape is outside, so only do this once\n    if (node._temporaryRemoved) return;\n    node._temporaryRemoved = true;\n    this.engine.removeNode(node); // remove placeholder as well, otherwise it's a sign node is not in our list, which is a bigger issue\n    node.el = node._isExternal && helper ? helper : el; // point back to real item being dragged\n    if (this.opts.removable === true) {\n      // boolean vs a class string\n      // item leaving us and we are supposed to remove on leave (no need to drag onto trash) mark it so\n      this._itemRemoving(el, true);\n    }\n    // finally if item originally came from another grid, but left us, restore things back to prev info\n    if (el._gridstackNodeOrig) {\n      // console.log('leave delete _gridstackNodeOrig') // TEST\n      el.gridstackNode = el._gridstackNodeOrig;\n      delete el._gridstackNodeOrig;\n    } else if (node._isExternal) {\n      // item came from outside (like a toolbar) so nuke any node info\n      delete node.el;\n      delete el.gridstackNode;\n      // and restore all nodes back to original\n      this.engine.restoreInitial();\n    }\n  }\n  // legacy method removed\n  commit() {\n    utils_1.obsolete(this, this.batchUpdate(false), 'commit', 'batchUpdate', '5.2');\n    return this;\n  }\n}\nexports.GridStack = GridStack;\n/** scoping so users can call GridStack.Utils.sort() for example */\nGridStack.Utils = utils_1.Utils;\n/** scoping so users can call new GridStack.Engine(12) for example */\nGridStack.Engine = gridstack_engine_1.GridStackEngine;\nGridStack.GDRev = '7.2.3';","map":{"version":3,"names":["gridstack_engine_1","require","utils_1","types_1","dd_gridstack_1","dd_touch_1","dd_manager_1","dd","DDGridStack","__exportStar","exports","GridStack","constructor","el","opts","arguments","length","undefined","_gsEventHandler","_extraDragRow","classList","contains","add","row","minRow","maxRow","rowAttr","Utils","toNumber","getAttribute","column","anyOpts","minWidth","oneColumnSize","alwaysShowResizeHandle","_alwaysShowResizeHandle","defaults","Object","assign","cloneDeep","gridDefaults","staticGrid","toBool","draggable","handle","handleClass","removableOptions","accept","itemClass","animate","_initMargin","disableOneColumnMode","_widthOrContainer","_prevColumn","getColumn","rtl","style","direction","parentGridItem","_a","closestUpByClass","gridstackNode","subGrid","_isAutoCellHeight","cellHeight","cellHeightUnit","isTouch","_styleSheetClass","GridStackEngine","_idSeq","_setStaticClass","engineClass","engine","float","onChange","cbNodes","maxH","nodes","forEach","n","Math","max","y","h","_removeDOM","remove","_writePosAttr","_updateStyles","auto","batchUpdate","elements","getGridItems","x","parseInt","push","i","Number","isNaN","sort","a","b","e","_prepareElement","children","load","setAnimation","dragIn","setupDragIn","dragInOptions","subGridDynamic","DDManager","pauseDrag","_b","pause","_setupRemoveDrop","_setupAcceptWidget","_updateWindowResizeEvent","init","options","elOrString","getGridElement","console","error","gridstack","initAll","selector","grids","getGridElements","addGrid","parent","opt","doc","document","implementation","createHTMLDocument","body","innerHTML","class","appendChild","grid","registerEngine","placeholder","_placeholder","placeholderChild","createElement","className","placeholderText","placeholderClass","addWidget","els","isGridStackWidget","w","content","node","addRemoveCB","domAttr","_readAttr","prepareNode","_writeAttr","_insertNotAppend","prepend","_updateContainerHeight","makeSubGrid","_ignoreLayoutsNodeChange","_triggerAddEvent","_triggerChangeEvent","ops","nodeToAdd","saveContent","makeWidget","subGridTemplate","_c","autoColumn","querySelector","newItem","newItemOpt","_removeDD","removeInternalForSave","_prepareDragDropByNode","transition","update","setTimeout","_moving","_isTemp","_autoColumn","window","simulateMouseEvent","_event","removeAsSubGrid","nodeThatRemoved","pGrid","removeWidget","save","saveGridOpt","list","sub","listOrOpt","o","marginBottom","marginTop","marginRight","marginLeft","margin","origShow","removeInternalAndSame","layout","addRemove","items","some","cacheLayout","prevCB","removed","copyNodes","item","find","id","removedNodes","flag","_triggerRemoveEvent","getCellHeight","forcePixel","height","round","offsetHeight","rows","getBoundingClientRect","val","marginDiff","cellWidth","data","parseHeight","unit","clientWidth","parentElement","innerWidth","compact","oldColumn","domNodes","oneColumnModeDomSort","updateNodeWidths","Array","from","filter","matches","destroy","removeDOM","setStatic","removeAll","parentNode","removeChild","_removeStylesheet","removeAttribute","getFloat","getCellFromPixel","position","useDocRelative","box","containerPos","top","documentElement","scrollTop","left","offsetTop","offsetLeft","relativeLeft","relativeTop","columnWidth","width","rowHeight","floor","getRow","isAreaEmpty","getElement","on","name","callback","indexOf","names","split","noData","event","detail","addEventListener","log","off","removeEventListener","triggerEvent","getElements","removeNode","doAnimate","updateClass","recurse","warn","autoPosition","keys","m","k","minW","minH","maxW","changed","ddChanged","key","cleanNodes","beginUpdate","moveNode","endUpdate","value","isMultiValue","marginUnit","getMargin","willItFit","batchMode","getDirtyNodes","layoutsNodesChange","_triggerEvent","saveInitial","addedNodes","_dirty","type","CustomEvent","bubbles","Event","dispatchEvent","_styles","removeStylesheet","forceUpdate","prefix","styleLocation","styleInHead","createStylesheet","_max","addCSSRule","bottom","right","getHeight","setAttribute","String","removeProperty","minHeight","triggerAddEvent","copy","addNode","same","attrs","noResize","noMove","locked","hasOwnProperty","classes","onParentResize","changedColumn","oneColumn","cellHeightThrottle","_cellHeightThrottle","throttle","forceRemove","workTodo","_windowResizeBind","bind","margins","getDD","dragInDefaultOptions","isDraggable","movable","resizable","disable","enableMove","enableResize","enable","doEnable","disableDrag","disableResize","_initDD","ddElement","acceptWidgets","removable","droppable","onDrag","helper","ui","_temporaryRemoved","nodeBoundFix","_willFitPos","copyPos","_onStartMoving","_dragOrResize","canAccept","otherGrid","_leave","_isExternal","offsetWidth","_gridstackNodeOrig","cleanupNode","_itemRemoving","wasAdded","origNode","oGrid","cloneNode","removePositioningStyles","_isAboutToRemove","trashEl","isDroppable","onStartMoving","target","dragOrResize","onEndMoving","_lastTried","gridToNotify","_orig","start","stop","drag","resize","_lastUiPosition","_prevYPix","cacheRects","p","resizing","mLeft","mRight","mTop","mBottom","mHeight","mWidth","min","distance","scroll","updateScrollPosition","prev","collide","extra","updateScrollResize","size","rect","moveNodeCheck","_skipDown","restoreInitial","commit","obsolete","Engine","GDRev"],"sources":["/home/catarina.santos/litegride/node_modules/gridstack/src/gridstack.ts"],"sourcesContent":["/*!\r\n * GridStack 7.2.3\r\n * https://gridstackjs.com/\r\n *\r\n * Copyright (c) 2021-2022 Alain Dumesny\r\n * see root license https://github.com/gridstack/gridstack.js/tree/master/LICENSE\r\n */\r\nimport { GridStackEngine } from './gridstack-engine';\r\nimport { Utils, HeightData, obsolete } from './utils';\r\nimport { gridDefaults, ColumnOptions, GridItemHTMLElement, GridStackElement, GridStackEventHandlerCallback,\r\n  GridStackNode, GridStackWidget, numberOrString, DDUIData, DDDragInOpt, GridStackPosition, GridStackOptions,\r\n  dragInDefaultOptions, GridStackEventHandler, GridStackNodesHandler, AddRemoveFcn } from './types';\r\n\r\n/*\r\n * and include D&D by default\r\n * TODO: while we could generate a gridstack-static.js at smaller size - saves about 31k (41k -> 72k)\r\n * I don't know how to generate the DD only code at the remaining 31k to delay load as code depends on Gridstack.ts\r\n * also it caused loading issues in prod - see https://github.com/gridstack/gridstack.js/issues/2039\r\n */\r\nimport { DDGridStack } from './dd-gridstack';\r\nimport { isTouch } from './dd-touch';\r\nimport { DDManager } from './dd-manager';\r\nimport { DDElementHost } from './dd-element';\r\n/** global instance */\r\nconst dd = new DDGridStack;\r\n\r\n// export all dependent file as well to make it easier for users to just import the main file\r\nexport * from './types';\r\nexport * from './utils';\r\nexport * from './gridstack-engine';\r\nexport * from './dd-gridstack';\r\n\r\nexport interface GridHTMLElement extends HTMLElement {\r\n  gridstack?: GridStack; // grid's parent DOM element points back to grid class\r\n}\r\n/** list of possible events, or space separated list of them */\r\nexport type GridStackEvent = 'added' | 'change' | 'disable' | 'drag' | 'dragstart' | 'dragstop' | 'dropped' |\r\n  'enable' | 'removed' | 'resize' | 'resizestart' | 'resizestop' | string;\r\n\r\n/** Defines the coordinates of an object */\r\nexport interface MousePosition {\r\n  top: number;\r\n  left: number;\r\n}\r\n\r\n/** Defines the position of a cell inside the grid*/\r\nexport interface CellPosition {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\ninterface GridCSSStyleSheet extends CSSStyleSheet {\r\n  _max?: number; // internal tracker of the max # of rows we created\r\n}\r\n\r\n// extend with internal fields we need - TODO: move other items in here\r\ninterface InternalGridStackOptions extends GridStackOptions {\r\n  _alwaysShowResizeHandle?: true | false | 'mobile'; // so we can restore for save\r\n}\r\n\r\n/**\r\n * Main gridstack class - you will need to call `GridStack.init()` first to initialize your grid.\r\n * Note: your grid elements MUST have the following classes for the CSS layout to work:\r\n * @example\r\n * <div class=\"grid-stack\">\r\n *   <div class=\"grid-stack-item\">\r\n *     <div class=\"grid-stack-item-content\">Item 1</div>\r\n *   </div>\r\n * </div>\r\n */\r\nexport class GridStack {\r\n\r\n  /**\r\n   * initializing the HTML element, or selector string, into a grid will return the grid. Calling it again will\r\n   * simply return the existing instance (ignore any passed options). There is also an initAll() version that support\r\n   * multiple grids initialization at once. Or you can use addGrid() to create the entire grid from JSON.\r\n   * @param options grid options (optional)\r\n   * @param elOrString element or CSS selector (first one used) to convert to a grid (default to '.grid-stack' class selector)\r\n   *\r\n   * @example\r\n   * let grid = GridStack.init();\r\n   *\r\n   * Note: the HTMLElement (of type GridHTMLElement) will store a `gridstack: GridStack` value that can be retrieve later\r\n   * let grid = document.querySelector('.grid-stack').gridstack;\r\n   */\r\n  public static init(options: GridStackOptions = {}, elOrString: GridStackElement = '.grid-stack'): GridStack {\r\n    let el = GridStack.getGridElement(elOrString);\r\n    if (!el) {\r\n      if (typeof elOrString === 'string') {\r\n        console.error('GridStack.initAll() no grid was found with selector \"' + elOrString + '\" - element missing or wrong selector ?' +\r\n        '\\nNote: \".grid-stack\" is required for proper CSS styling and drag/drop, and is the default selector.');\r\n      } else {\r\n        console.error('GridStack.init() no grid element was passed.');\r\n      }\r\n      return null;\r\n    }\r\n    if (!el.gridstack) {\r\n      el.gridstack = new GridStack(el, Utils.cloneDeep(options));\r\n    }\r\n    return el.gridstack\r\n  }\r\n\r\n  /**\r\n   * Will initialize a list of elements (given a selector) and return an array of grids.\r\n   * @param options grid options (optional)\r\n   * @param selector elements selector to convert to grids (default to '.grid-stack' class selector)\r\n   *\r\n   * @example\r\n   * let grids = GridStack.initAll();\r\n   * grids.forEach(...)\r\n   */\r\n  public static initAll(options: GridStackOptions = {}, selector = '.grid-stack'): GridStack[] {\r\n    let grids: GridStack[] = [];\r\n    GridStack.getGridElements(selector).forEach(el => {\r\n      if (!el.gridstack) {\r\n        el.gridstack = new GridStack(el, Utils.cloneDeep(options));\r\n        delete options.dragIn; delete options.dragInOptions; // only need to be done once (really a static global thing, not per grid)\r\n      }\r\n      grids.push(el.gridstack);\r\n    });\r\n    if (grids.length === 0) {\r\n      console.error('GridStack.initAll() no grid was found with selector \"' + selector + '\" - element missing or wrong selector ?' +\r\n      '\\nNote: \".grid-stack\" is required for proper CSS styling and drag/drop, and is the default selector.');\r\n    }\r\n    return grids;\r\n  }\r\n\r\n  /**\r\n   * call to create a grid with the given options, including loading any children from JSON structure. This will call GridStack.init(), then\r\n   * grid.load() on any passed children (recursively). Great alternative to calling init() if you want entire grid to come from\r\n   * JSON serialized data, including options.\r\n   * @param parent HTML element parent to the grid\r\n   * @param opt grids options used to initialize the grid, and list of children\r\n   */\r\n  public static addGrid(parent: HTMLElement, opt: GridStackOptions = {}): GridStack {\r\n    if (!parent) return null;\r\n\r\n    // create the grid element, but check if the passed 'parent' already has grid styling and should be used instead\r\n    let el = parent;\r\n    if (!parent.classList.contains('grid-stack')) {\r\n      let doc = document.implementation.createHTMLDocument(''); // IE needs a param\r\n      doc.body.innerHTML = `<div class=\"grid-stack ${opt.class || ''}\"></div>`;\r\n      el = doc.body.children[0] as HTMLElement;\r\n      parent.appendChild(el);\r\n    }\r\n\r\n    // create grid class and load any children\r\n    let grid = GridStack.init(opt, el);\r\n    return grid;\r\n  }\r\n\r\n  /** call this method to register your engine instead of the default one.\r\n   * See instead `GridStackOptions.engineClass` if you only need to\r\n   * replace just one instance.\r\n   */\r\n  static registerEngine(engineClass: typeof GridStackEngine): void {\r\n    GridStack.engineClass = engineClass;\r\n  }\r\n\r\n  /** scoping so users can call GridStack.Utils.sort() for example */\r\n  public static Utils = Utils;\r\n\r\n  /** scoping so users can call new GridStack.Engine(12) for example */\r\n  public static Engine = GridStackEngine;\r\n\r\n  /** the HTML element tied to this grid after it's been initialized */\r\n  public el: GridHTMLElement;\r\n\r\n  /** engine used to implement non DOM grid functionality */\r\n  public engine: GridStackEngine;\r\n\r\n  /** grid options - public for classes to access, but use methods to modify! */\r\n  public opts: GridStackOptions;\r\n\r\n  /** point to a parent grid item if we're nested (inside a grid-item in between 2 Grids) */\r\n  public parentGridItem?: GridStackNode;\r\n\r\n  protected static engineClass: typeof GridStackEngine;\r\n\r\n  /** @internal unique class name for our generated CSS style sheet */\r\n  protected _styleSheetClass?: string;\r\n  /** @internal true if we got created by drag over gesture, so we can removed on drag out (temporary) */\r\n  public _isTemp?: boolean;\r\n\r\n\r\n  /** @internal create placeholder DIV as needed */\r\n  public get placeholder(): HTMLElement {\r\n    if (!this._placeholder) {\r\n      let placeholderChild = document.createElement('div'); // child so padding match item-content\r\n      placeholderChild.className = 'placeholder-content';\r\n      if (this.opts.placeholderText) {\r\n        placeholderChild.innerHTML = this.opts.placeholderText;\r\n      }\r\n      this._placeholder = document.createElement('div');\r\n      this._placeholder.classList.add(this.opts.placeholderClass, gridDefaults.itemClass, this.opts.itemClass);\r\n      this.placeholder.appendChild(placeholderChild);\r\n    }\r\n    return this._placeholder;\r\n  }\r\n  /** @internal */\r\n  protected _placeholder: HTMLElement;\r\n  /** @internal */\r\n  protected _prevColumn: number;\r\n  /** @internal prevent cached layouts from being updated when loading into small column layouts */\r\n  protected _ignoreLayoutsNodeChange: boolean;\r\n  /** @internal */\r\n  public _gsEventHandler = {};\r\n  /** @internal */\r\n  protected _styles: GridCSSStyleSheet;\r\n  /** @internal flag to keep cells square during resize */\r\n  protected _isAutoCellHeight: boolean;\r\n  /** @internal track event binding to window resize so we can remove */\r\n  protected _windowResizeBind: () => void;\r\n  /** @internal limit auto cell resizing method */\r\n  protected _cellHeightThrottle: () => void;\r\n  /** @internal true when loading items to insert first rather than append */\r\n  protected _insertNotAppend: boolean;\r\n  /** @internal extra row added when dragging at the bottom of the grid */\r\n  protected _extraDragRow = 0;\r\n  /** @internal true if nested grid should get column count from our width */\r\n  protected _autoColumn?: boolean;\r\n\r\n  /**\r\n   * Construct a grid item from the given element and options\r\n   * @param el\r\n   * @param opts\r\n   */\r\n  public constructor(el: GridHTMLElement, opts: GridStackOptions = {}) {\r\n    this.el = el; // exposed HTML element to the user\r\n    opts = opts || {}; // handles null/undefined/0\r\n\r\n    if (!el.classList.contains('grid-stack')) {\r\n      this.el.classList.add('grid-stack');\r\n    }\r\n\r\n    // if row property exists, replace minRow and maxRow instead\r\n    if (opts.row) {\r\n      opts.minRow = opts.maxRow = opts.row;\r\n      delete opts.row;\r\n    }\r\n    let rowAttr = Utils.toNumber(el.getAttribute('gs-row'));\r\n\r\n    // flag only valid in sub-grids (handled by parent, not here)\r\n    if (opts.column === 'auto') {\r\n      delete opts.column;\r\n    }\r\n    // 'minWidth' legacy support in 5.1\r\n    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\r\n    let anyOpts = opts as any;\r\n    if (anyOpts.minWidth !== undefined) {\r\n      opts.oneColumnSize = opts.oneColumnSize || anyOpts.minWidth;\r\n      delete anyOpts.minWidth;\r\n    }\r\n    // save original setting so we can restore on save\r\n    if (opts.alwaysShowResizeHandle !== undefined) {\r\n      (opts as InternalGridStackOptions)._alwaysShowResizeHandle = opts.alwaysShowResizeHandle;\r\n    }\r\n\r\n    // elements DOM attributes override any passed options (like CSS style) - merge the two together\r\n    let defaults: GridStackOptions = {...Utils.cloneDeep(gridDefaults),\r\n      column: Utils.toNumber(el.getAttribute('gs-column')) || gridDefaults.column,\r\n      minRow: rowAttr ? rowAttr : Utils.toNumber(el.getAttribute('gs-min-row')) || gridDefaults.minRow,\r\n      maxRow: rowAttr ? rowAttr : Utils.toNumber(el.getAttribute('gs-max-row')) || gridDefaults.maxRow,\r\n      staticGrid: Utils.toBool(el.getAttribute('gs-static')) || gridDefaults.staticGrid,\r\n      draggable: {\r\n        handle: (opts.handleClass ? '.' + opts.handleClass : (opts.handle ? opts.handle : '')) || gridDefaults.draggable.handle,\r\n      },\r\n      removableOptions: {\r\n        accept: opts.itemClass ? '.' + opts.itemClass : gridDefaults.removableOptions.accept,\r\n      },\r\n    };\r\n    if (el.getAttribute('gs-animate')) { // default to true, but if set to false use that instead\r\n      defaults.animate = Utils.toBool(el.getAttribute('gs-animate'))\r\n    }\r\n\r\n    this.opts = Utils.defaults(opts, defaults);\r\n    opts = null; // make sure we use this.opts instead\r\n    this._initMargin(); // part of settings defaults...\r\n\r\n    // Now check if we're loading into 1 column mode FIRST so we don't do un-necessary work (like cellHeight = width / 12 then go 1 column)\r\n    if (this.opts.column !== 1 && !this.opts.disableOneColumnMode && this._widthOrContainer() <= this.opts.oneColumnSize) {\r\n      this._prevColumn = this.getColumn();\r\n      this.opts.column = 1;\r\n    }\r\n\r\n    if (this.opts.rtl === 'auto') {\r\n      this.opts.rtl = (el.style.direction === 'rtl');\r\n    }\r\n    if (this.opts.rtl) {\r\n      this.el.classList.add('grid-stack-rtl');\r\n    }\r\n\r\n    // check if we're been nested, and if so update our style and keep pointer around (used during save)\r\n    let parentGridItem = (Utils.closestUpByClass(this.el, gridDefaults.itemClass) as GridItemHTMLElement)?.gridstackNode;\r\n    if (parentGridItem) {\r\n      parentGridItem.subGrid = this;\r\n      this.parentGridItem = parentGridItem;\r\n      this.el.classList.add('grid-stack-nested');\r\n      parentGridItem.el.classList.add('grid-stack-sub-grid');\r\n    }\r\n\r\n    this._isAutoCellHeight = (this.opts.cellHeight === 'auto');\r\n    if (this._isAutoCellHeight || this.opts.cellHeight === 'initial') {\r\n      // make the cell content square initially (will use resize/column event to keep it square)\r\n      this.cellHeight(undefined, false);\r\n    } else {\r\n      // append unit if any are set\r\n      if (typeof this.opts.cellHeight == 'number' && this.opts.cellHeightUnit && this.opts.cellHeightUnit !== gridDefaults.cellHeightUnit) {\r\n        this.opts.cellHeight = this.opts.cellHeight + this.opts.cellHeightUnit;\r\n        delete this.opts.cellHeightUnit;\r\n      }\r\n      this.cellHeight(this.opts.cellHeight, false);\r\n    }\r\n\r\n    // see if we need to adjust auto-hide\r\n    if (this.opts.alwaysShowResizeHandle === 'mobile') {\r\n      this.opts.alwaysShowResizeHandle = isTouch;\r\n    }\r\n\r\n    this._styleSheetClass = 'grid-stack-instance-' + GridStackEngine._idSeq++;\r\n    this.el.classList.add(this._styleSheetClass);\r\n\r\n    this._setStaticClass();\r\n\r\n    let engineClass = this.opts.engineClass || GridStack.engineClass || GridStackEngine;\r\n    this.engine = new engineClass({\r\n      column: this.getColumn(),\r\n      float: this.opts.float,\r\n      maxRow: this.opts.maxRow,\r\n      onChange: (cbNodes) => {\r\n        let maxH = 0;\r\n        this.engine.nodes.forEach(n => { maxH = Math.max(maxH, n.y + n.h) });\r\n        cbNodes.forEach(n => {\r\n          let el = n.el;\r\n          if (!el) return;\r\n          if (n._removeDOM) {\r\n            if (el) el.remove();\r\n            delete n._removeDOM;\r\n          } else {\r\n            this._writePosAttr(el, n);\r\n          }\r\n        });\r\n        this._updateStyles(false, maxH); // false = don't recreate, just append if need be\r\n      }\r\n    });\r\n\r\n    if (this.opts.auto) {\r\n      this.batchUpdate(); // prevent in between re-layout #1535 TODO: this only set float=true, need to prevent collision check...\r\n      let elements: {el: HTMLElement; i: number}[] = [];\r\n      let column = this.getColumn();\r\n      if (column === 1 && this._prevColumn) column = this._prevColumn; // do 12 column when reading into 1 column mode\r\n      this.getGridItems().forEach(el => { // get dom elements (not nodes yet)\r\n        let x = parseInt(el.getAttribute('gs-x'));\r\n        let y = parseInt(el.getAttribute('gs-y'));\r\n        elements.push({\r\n          el,\r\n          // if x,y are missing (autoPosition) add them to end of list - but keep their respective DOM order\r\n          i: (Number.isNaN(x) ? 1000 : x) + (Number.isNaN(y) ? 1000 : y) * column\r\n        });\r\n      });\r\n      elements.sort((a, b) => b.i - a.i).forEach(e => this._prepareElement(e.el)); // revert sort so lowest item wins\r\n      this.batchUpdate(false);\r\n    }\r\n\r\n    // load any passed in children as well, which overrides any DOM layout done above\r\n    if (this.opts.children) {\r\n      let children = this.opts.children;\r\n      delete this.opts.children;\r\n      if (children.length) this.load(children); // don't load empty\r\n    }\r\n\r\n    this.setAnimation(this.opts.animate);\r\n\r\n    this._updateStyles();\r\n    if (this.opts.column != 12) {\r\n      this.el.classList.add('grid-stack-' + this.opts.column);\r\n    }\r\n\r\n    // legacy support to appear 'per grid` options when really global.\r\n    if (this.opts.dragIn) GridStack.setupDragIn(this.opts.dragIn, this.opts.dragInOptions);\r\n    delete this.opts.dragIn;\r\n    delete this.opts.dragInOptions;\r\n\r\n    // dynamic grids require pausing during drag to detect over to nest vs push\r\n    if (this.opts.subGridDynamic && !DDManager.pauseDrag) DDManager.pauseDrag = true;\r\n    if (this.opts.draggable?.pause !== undefined) DDManager.pauseDrag = this.opts.draggable.pause;\r\n\r\n    this._setupRemoveDrop();\r\n    this._setupAcceptWidget();\r\n    this._updateWindowResizeEvent();\r\n  }\r\n\r\n  /**\r\n   * add a new widget and returns it.\r\n   *\r\n   * Widget will be always placed even if result height is more than actual grid height.\r\n   * You need to use `willItFit()` before calling addWidget for additional check.\r\n   * See also `makeWidget()`.\r\n   *\r\n   * @example\r\n   * let grid = GridStack.init();\r\n   * grid.addWidget({w: 3, content: 'hello'});\r\n   * grid.addWidget('<div class=\"grid-stack-item\"><div class=\"grid-stack-item-content\">hello</div></div>', {w: 3});\r\n   *\r\n   * @param el  GridStackWidget (which can have content string as well), html element, or string definition to add\r\n   * @param options widget position/size options (optional, and ignore if first param is already option) - see GridStackWidget\r\n   */\r\n  public addWidget(els?: GridStackWidget | GridStackElement, options?: GridStackWidget): GridItemHTMLElement {\r\n    function isGridStackWidget(w: GridStackNode): w is GridStackNode { // https://medium.com/ovrsea/checking-the-type-of-an-object-in-typescript-the-type-guards-24d98d9119b0\r\n      return w.el !== undefined || w.x !== undefined || w.y !== undefined || w.w !== undefined || w.h !== undefined || w.content !== undefined ? true : false;\r\n    }\r\n\r\n    let el: HTMLElement;\r\n    let node: GridStackNode;\r\n    if (typeof els === 'string') {\r\n      let doc = document.implementation.createHTMLDocument(''); // IE needs a param\r\n      doc.body.innerHTML = els;\r\n      el = doc.body.children[0] as HTMLElement;\r\n    } else if (arguments.length === 0 || arguments.length === 1 && isGridStackWidget(els)) {\r\n      node = options = els;\r\n      if (node?.el) {\r\n        el = node.el; // re-use element stored in the node\r\n      } else if (this.opts.addRemoveCB) {\r\n        el = this.opts.addRemoveCB(this, options, true);\r\n      } else {\r\n        let content = options?.content || '';\r\n        let doc = document.implementation.createHTMLDocument(''); // IE needs a param\r\n        doc.body.innerHTML = `<div class=\"grid-stack-item ${this.opts.itemClass || ''}\"><div class=\"grid-stack-item-content\">${content}</div></div>`;\r\n        el = doc.body.children[0] as HTMLElement;\r\n      }\r\n    } else {\r\n      el = els as HTMLElement;\r\n    }\r\n\r\n    if (!el) return;\r\n\r\n    // Tempting to initialize the passed in opt with default and valid values, but this break knockout demos\r\n    // as the actual value are filled in when _prepareElement() calls el.getAttribute('gs-xyz') before adding the node.\r\n    // So make sure we load any DOM attributes that are not specified in passed in options (which override)\r\n    let domAttr = this._readAttr(el);\r\n    options = Utils.cloneDeep(options) || {};  // make a copy before we modify in case caller re-uses it\r\n    Utils.defaults(options, domAttr);\r\n    node = this.engine.prepareNode(options);\r\n    this._writeAttr(el, options);\r\n\r\n    if (this._insertNotAppend) {\r\n      this.el.prepend(el);\r\n    } else {\r\n      this.el.appendChild(el);\r\n    }\r\n\r\n    // similar to makeWidget() that doesn't read attr again and worse re-create a new node and loose any _id\r\n    this._prepareElement(el, true, options);\r\n    this._updateContainerHeight();\r\n\r\n    // see if there is a sub-grid to create\r\n    if (node.subGrid) {\r\n      this.makeSubGrid(node.el, undefined, undefined, false);\r\n    }\r\n\r\n    // if we're adding an item into 1 column (_prevColumn is set only when going to 1) make sure\r\n    // we don't override the larger 12 column layout that was already saved. #1985\r\n    if (this._prevColumn && this.opts.column === 1) {\r\n      this._ignoreLayoutsNodeChange = true;\r\n    }\r\n    this._triggerAddEvent();\r\n    this._triggerChangeEvent();\r\n    delete this._ignoreLayoutsNodeChange;\r\n\r\n    return el;\r\n  }\r\n\r\n  /**\r\n   * Convert an existing gridItem element into a sub-grid with the given (optional) options, else inherit them\r\n   * from the parent's subGrid options.\r\n   * @param el gridItem element to convert\r\n   * @param ops (optional) sub-grid options, else default to node, then parent settings, else defaults\r\n   * @param nodeToAdd (optional) node to add to the newly created sub grid (used when dragging over existing regular item)\r\n   * @returns newly created grid\r\n   */\r\n  public makeSubGrid(el: GridItemHTMLElement, ops?: GridStackOptions, nodeToAdd?: GridStackNode, saveContent = true): GridStack {\r\n    let node = el.gridstackNode;\r\n    if (!node) {\r\n      node = this.makeWidget(el).gridstackNode;\r\n    }\r\n    if ((node.subGrid as GridStack)?.el) return node.subGrid as GridStack; // already done\r\n\r\n    // find the template subGrid stored on a parent as fallback...\r\n    let subGridTemplate: GridStackOptions; // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n    let grid: GridStack = this;\r\n    while (grid && !subGridTemplate) {\r\n      subGridTemplate = grid.opts?.subGrid;\r\n      grid = grid.parentGridItem?.grid;\r\n    }\r\n    //... and set the create options\r\n    ops = Utils.cloneDeep({...(subGridTemplate || {}), children: undefined, ...(ops || node.subGrid as GridStackOptions)});\r\n    node.subGrid = ops;\r\n\r\n    // if column special case it set, remember that flag and set default\r\n    let autoColumn: boolean;\r\n    if (ops.column === 'auto') {\r\n      autoColumn = true;\r\n      ops.column = Math.max(node.w || 1, nodeToAdd?.w || 1);\r\n      ops.disableOneColumnMode = true; // driven by parent\r\n    }\r\n\r\n    // if we're converting an existing full item, move over the content to be the first sub item in the new grid\r\n    // TODO: support this.opts.addRemoveCB for frameworks\r\n    let content = node.el.querySelector('.grid-stack-item-content') as HTMLElement;\r\n    let newItem: HTMLElement;\r\n    let newItemOpt: GridStackNode;\r\n    if (saveContent) {\r\n      this._removeDD(node.el); // remove D&D since it's set on content div\r\n      let doc = document.implementation.createHTMLDocument(''); // IE needs a param\r\n      doc.body.innerHTML = `<div class=\"grid-stack-item\"></div>`;\r\n      newItem = doc.body.children[0] as HTMLElement;\r\n      newItem.appendChild(content);\r\n      newItemOpt = {...node, x:0, y:0};\r\n      Utils.removeInternalForSave(newItemOpt);\r\n      delete newItemOpt.subGrid;\r\n      if (node.content) {\r\n        newItemOpt.content = node.content;\r\n        delete node.content;\r\n      }\r\n      doc.body.innerHTML = `<div class=\"grid-stack-item-content\"></div>`;\r\n      content = doc.body.children[0] as HTMLElement;\r\n      node.el.appendChild(content);\r\n      this._prepareDragDropByNode(node); // ... and restore original D&D\r\n    }\r\n\r\n    // if we're adding an additional item, make the container large enough to have them both\r\n    if (nodeToAdd) {\r\n      let w = autoColumn ? ops.column : node.w;\r\n      let h = node.h + nodeToAdd.h;\r\n      let style = node.el.style;\r\n      style.transition = 'none'; // show up instantly so we don't see scrollbar with nodeToAdd\r\n      this.update(node.el, {w, h});\r\n      setTimeout(() =>  style.transition = null); // recover animation\r\n    }\r\n\r\n    let subGrid = node.subGrid = GridStack.addGrid(content, ops);\r\n    if (nodeToAdd?._moving) subGrid._isTemp = true; // prevent re-nesting as we add over\r\n    if (autoColumn) subGrid._autoColumn = true;\r\n\r\n    // add the original content back as a child of hte newly created grid\r\n    if (saveContent) {\r\n      subGrid.addWidget(newItem, newItemOpt);\r\n    }\r\n\r\n    // now add any additional node\r\n    if (nodeToAdd) {\r\n      if (nodeToAdd._moving) {\r\n        // create an artificial event even for the just created grid to receive this item\r\n        window.setTimeout(() => Utils.simulateMouseEvent(nodeToAdd._event, 'mouseenter', subGrid.el), 0);\r\n      } else {\r\n        subGrid.addWidget(node.el, node);\r\n      }\r\n    }\r\n    return subGrid;\r\n  }\r\n\r\n  /**\r\n   * called when an item was converted into a nested grid to accommodate a dragged over item, but then item leaves - return back\r\n   * to the original grid-item. Also called to remove empty sub-grids when last item is dragged out (since re-creating is simple)\r\n   */\r\n  public removeAsSubGrid(nodeThatRemoved?: GridStackNode): void {\r\n    let pGrid = this.parentGridItem?.grid;\r\n    if (!pGrid) return;\r\n\r\n    pGrid.batchUpdate();\r\n    pGrid.removeWidget(this.parentGridItem.el, true, true);\r\n    this.engine.nodes.forEach(n => {\r\n      // migrate any children over and offsetting by our location\r\n      n.x += this.parentGridItem.x;\r\n      n.y += this.parentGridItem.y;\r\n      pGrid.addWidget(n.el, n);\r\n    });\r\n    pGrid.batchUpdate(false);\r\n    delete this.parentGridItem;\r\n\r\n    // create an artificial event for the original grid now that this one is gone (got a leave, but won't get enter)\r\n    if (nodeThatRemoved) {\r\n      window.setTimeout(() => Utils.simulateMouseEvent(nodeThatRemoved._event, 'mouseenter', pGrid.el), 0);\r\n    }\r\n  }\r\n\r\n  /**\r\n  /**\r\n   * saves the current layout returning a list of widgets for serialization which might include any nested grids.\r\n   * @param saveContent if true (default) the latest html inside .grid-stack-content will be saved to GridStackWidget.content field, else it will\r\n   * be removed.\r\n   * @param saveGridOpt if true (default false), save the grid options itself, so you can call the new GridStack.addGrid()\r\n   * to recreate everything from scratch. GridStackOptions.children would then contain the widget list instead.\r\n   * @returns list of widgets or full grid option, including .children list of widgets\r\n   */\r\n  public save(saveContent = true, saveGridOpt = false): GridStackWidget[] | GridStackOptions {\r\n    // return copied nodes we can modify at will...\r\n    let list = this.engine.save(saveContent);\r\n\r\n    // check for HTML content and nested grids\r\n    list.forEach(n => {\r\n      if (saveContent && n.el && !n.subGrid) { // sub-grid are saved differently, not plain content\r\n        let sub = n.el.querySelector('.grid-stack-item-content');\r\n        n.content = sub ? sub.innerHTML : undefined;\r\n        if (!n.content) delete n.content;\r\n      } else {\r\n        if (!saveContent) { delete n.content; }\r\n        // check for nested grid\r\n        if ((n.subGrid as GridStack)?.el) {\r\n          const listOrOpt = (n.subGrid as GridStack).save(saveContent, saveGridOpt);\r\n          n.subGrid = (saveGridOpt ? listOrOpt : {children: listOrOpt}) as GridStackOptions;\r\n        }\r\n      }\r\n      delete n.el;\r\n    });\r\n\r\n    // check if save entire grid options (needed for recursive) + children...\r\n    if (saveGridOpt) {\r\n      let o: InternalGridStackOptions = Utils.cloneDeep(this.opts);\r\n      // delete default values that will be recreated on launch\r\n      if (o.marginBottom === o.marginTop && o.marginRight === o.marginLeft && o.marginTop === o.marginRight) {\r\n        o.margin = o.marginTop;\r\n        delete o.marginTop; delete o.marginRight; delete o.marginBottom; delete o.marginLeft;\r\n      }\r\n      if (o.rtl === (this.el.style.direction === 'rtl')) { o.rtl = 'auto' }\r\n      if (this._isAutoCellHeight) {\r\n        o.cellHeight = 'auto'\r\n      }\r\n      if (this._autoColumn) {\r\n        o.column = 'auto';\r\n        delete o.disableOneColumnMode;\r\n      }\r\n      const origShow = o._alwaysShowResizeHandle;\r\n      delete o._alwaysShowResizeHandle;\r\n      if (origShow !== undefined) {\r\n        o.alwaysShowResizeHandle = origShow;\r\n      } else {\r\n        delete o.alwaysShowResizeHandle;\r\n      }\r\n      Utils.removeInternalAndSame(o, gridDefaults);\r\n      o.children = list;\r\n      return o;\r\n    }\r\n\r\n    return list;\r\n  }\r\n\r\n  /**\r\n   * load the widgets from a list. This will call update() on each (matching by id) or add/remove widgets that are not there.\r\n   *\r\n   * @param layout list of widgets definition to update/create\r\n   * @param addAndRemove boolean (default true) or callback method can be passed to control if and how missing widgets can be added/removed, giving\r\n   * the user control of insertion.\r\n   *\r\n   * @example\r\n   * see http://gridstackjs.com/demo/serialization.html\r\n   **/\r\n  public load(layout: GridStackWidget[], addRemove: boolean | AddRemoveFcn = this.opts.addRemoveCB || true): GridStack {\r\n    let items = GridStack.Utils.sort([...layout], -1, this._prevColumn || this.getColumn()); // make copy before we mod/sort\r\n    this._insertNotAppend = true; // since create in reverse order...\r\n\r\n    // if we're loading a layout into for example 1 column (_prevColumn is set only when going to 1) and items don't fit, make sure to save\r\n    // the original wanted layout so we can scale back up correctly #1471\r\n    if (this._prevColumn && this._prevColumn !== this.opts.column && items.some(n => (n.x + n.w) > this.opts.column)) {\r\n      this._ignoreLayoutsNodeChange = true; // skip layout update\r\n      this.engine.cacheLayout(items, this._prevColumn, true);\r\n    }\r\n\r\n    // if given a different callback, temporally set it as global option to creating will use it\r\n    const prevCB = this.opts.addRemoveCB;\r\n    if (typeof(addRemove) === 'function') this.opts.addRemoveCB = addRemove as AddRemoveFcn;\r\n\r\n    let removed: GridStackNode[] = [];\r\n    this.batchUpdate();\r\n\r\n    // see if any items are missing from new layout and need to be removed first\r\n    if (addRemove) {\r\n      let copyNodes = [...this.engine.nodes]; // don't loop through array you modify\r\n      copyNodes.forEach(n => {\r\n        let item = items.find(w => n.id === w.id);\r\n        if (!item) {\r\n          if (this.opts.addRemoveCB)\r\n            this.opts.addRemoveCB(this, n, false);\r\n          removed.push(n); // batch keep track\r\n          this.removeWidget(n.el, true, false);\r\n        }\r\n      });\r\n    }\r\n\r\n    // now add/update the widgets\r\n    items.forEach(w => {\r\n      let item = (w.id || w.id === 0) ? this.engine.nodes.find(n => n.id === w.id) : undefined;\r\n      if (item) {\r\n        this.update(item.el, w);\r\n        if (w.subGrid && (w.subGrid as GridStackOptions).children) { // update any sub grid as well\r\n          let sub = item.el.querySelector('.grid-stack') as GridHTMLElement;\r\n          if (sub && sub.gridstack) {\r\n            sub.gridstack.load((w.subGrid as GridStackOptions).children); // TODO: support updating grid options ?\r\n            this._insertNotAppend = true; // got reset by above call\r\n          }\r\n        }\r\n      } else if (addRemove) {\r\n        this.addWidget(w);\r\n      }\r\n    });\r\n\r\n    this.engine.removedNodes = removed;\r\n    this.batchUpdate(false);\r\n\r\n    // after commit, clear that flag\r\n    delete this._ignoreLayoutsNodeChange;\r\n    delete this._insertNotAppend;\r\n    prevCB ? this.opts.addRemoveCB = prevCB : delete this.opts.addRemoveCB;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * use before calling a bunch of `addWidget()` to prevent un-necessary relayouts in between (more efficient)\r\n   * and get a single event callback. You will see no changes until `batchUpdate(false)` is called.\r\n   */\r\n  public batchUpdate(flag = true): GridStack {\r\n    this.engine.batchUpdate(flag);\r\n    if (!flag) {\r\n      this._triggerRemoveEvent();\r\n      this._triggerAddEvent();\r\n      this._triggerChangeEvent();\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Gets current cell height.\r\n   */\r\n  public getCellHeight(forcePixel = false): number {\r\n    if (this.opts.cellHeight && this.opts.cellHeight !== 'auto' &&\r\n       (!forcePixel || !this.opts.cellHeightUnit || this.opts.cellHeightUnit === 'px')) {\r\n      return this.opts.cellHeight as number;\r\n    }\r\n    // else get first cell height\r\n    let el = this.el.querySelector('.' + this.opts.itemClass) as HTMLElement;\r\n    if (el) {\r\n      let height = Utils.toNumber(el.getAttribute('gs-h'));\r\n      return Math.round(el.offsetHeight / height);\r\n    }\r\n    // else do entire grid and # of rows (but doesn't work if min-height is the actual constrain)\r\n    let rows = parseInt(this.el.getAttribute('gs-current-row'));\r\n    return rows ? Math.round(this.el.getBoundingClientRect().height / rows) : this.opts.cellHeight as number;\r\n  }\r\n\r\n  /**\r\n   * Update current cell height - see `GridStackOptions.cellHeight` for format.\r\n   * This method rebuilds an internal CSS style sheet.\r\n   * Note: You can expect performance issues if call this method too often.\r\n   *\r\n   * @param val the cell height. If not passed (undefined), cells content will be made square (match width minus margin),\r\n   * if pass 0 the CSS will be generated by the application instead.\r\n   * @param update (Optional) if false, styles will not be updated\r\n   *\r\n   * @example\r\n   * grid.cellHeight(100); // same as 100px\r\n   * grid.cellHeight('70px');\r\n   * grid.cellHeight(grid.cellWidth() * 1.2);\r\n   */\r\n  public cellHeight(val?: numberOrString, update = true): GridStack {\r\n\r\n    // if not called internally, check if we're changing mode\r\n    if (update && val !== undefined) {\r\n      if (this._isAutoCellHeight !== (val === 'auto')) {\r\n        this._isAutoCellHeight = (val === 'auto');\r\n        this._updateWindowResizeEvent();\r\n      }\r\n    }\r\n    if (val === 'initial' || val === 'auto') { val = undefined; }\r\n\r\n    // make item content be square\r\n    if (val === undefined) {\r\n      let marginDiff = - (this.opts.marginRight as number) - (this.opts.marginLeft as number)\r\n        + (this.opts.marginTop as number) + (this.opts.marginBottom as number);\r\n      val = this.cellWidth() + marginDiff;\r\n    }\r\n\r\n    let data = Utils.parseHeight(val);\r\n    if (this.opts.cellHeightUnit === data.unit && this.opts.cellHeight === data.h) {\r\n      return this;\r\n    }\r\n    this.opts.cellHeightUnit = data.unit;\r\n    this.opts.cellHeight = data.h;\r\n\r\n    if (update) {\r\n      this._updateStyles(true); // true = force re-create for current # of rows\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** Gets current cell width. */\r\n  public cellWidth(): number {\r\n    return this._widthOrContainer() / this.getColumn();\r\n  }\r\n  /** return our expected width (or parent) for 1 column check */\r\n  protected _widthOrContainer(): number {\r\n    // use `offsetWidth` or `clientWidth` (no scrollbar) ?\r\n    // https://stackoverflow.com/questions/21064101/understanding-offsetwidth-clientwidth-scrollwidth-and-height-respectively\r\n    return (this.el.clientWidth || this.el.parentElement.clientWidth || window.innerWidth);\r\n  }\r\n\r\n  /** re-layout grid items to reclaim any empty space */\r\n  public compact(): GridStack {\r\n    this.engine.compact();\r\n    this._triggerChangeEvent();\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * set the number of columns in the grid. Will update existing widgets to conform to new number of columns,\r\n   * as well as cache the original layout so you can revert back to previous positions without loss.\r\n   * Requires `gridstack-extra.css` or `gridstack-extra.min.css` for [2-11],\r\n   * else you will need to generate correct CSS (see https://github.com/gridstack/gridstack.js#change-grid-columns)\r\n   * @param column - Integer > 0 (default 12).\r\n   * @param layout specify the type of re-layout that will happen (position, size, etc...).\r\n   * Note: items will never be outside of the current column boundaries. default (moveScale). Ignored for 1 column\r\n   */\r\n  public column(column: number, layout: ColumnOptions = 'moveScale'): GridStack {\r\n    if (column < 1 || this.opts.column === column) return this;\r\n    let oldColumn = this.getColumn();\r\n\r\n    // if we go into 1 column mode (which happens if we're sized less than minW unless disableOneColumnMode is on)\r\n    // then remember the original columns so we can restore.\r\n    if (column === 1) {\r\n      this._prevColumn = oldColumn;\r\n    } else {\r\n      delete this._prevColumn;\r\n    }\r\n\r\n    this.el.classList.remove('grid-stack-' + oldColumn);\r\n    this.el.classList.add('grid-stack-' + column);\r\n    this.opts.column = this.engine.column = column;\r\n\r\n    // update the items now - see if the dom order nodes should be passed instead (else default to current list)\r\n    let domNodes: GridStackNode[];\r\n    if (column === 1 && this.opts.oneColumnModeDomSort) {\r\n      domNodes = [];\r\n      this.getGridItems().forEach(el => { // get dom elements in order\r\n        if (el.gridstackNode) { domNodes.push(el.gridstackNode); }\r\n      });\r\n      if (!domNodes.length) { domNodes = undefined; }\r\n    }\r\n    this.engine.updateNodeWidths(oldColumn, column, domNodes, layout);\r\n    if (this._isAutoCellHeight) this.cellHeight();\r\n\r\n    // and trigger our event last...\r\n    this._ignoreLayoutsNodeChange = true; // skip layout update\r\n    this._triggerChangeEvent();\r\n    delete this._ignoreLayoutsNodeChange;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * get the number of columns in the grid (default 12)\r\n   */\r\n  public getColumn(): number {\r\n    return this.opts.column as number;\r\n  }\r\n\r\n  /** returns an array of grid HTML elements (no placeholder) - used to iterate through our children in DOM order */\r\n  public getGridItems(): GridItemHTMLElement[] {\r\n    return Array.from(this.el.children)\r\n      .filter((el: HTMLElement) => el.matches('.' + this.opts.itemClass) && !el.matches('.' + this.opts.placeholderClass)) as GridItemHTMLElement[];\r\n  }\r\n\r\n  /**\r\n   * Destroys a grid instance. DO NOT CALL any methods or access any vars after this as it will free up members.\r\n   * @param removeDOM if `false` grid and items HTML elements will not be removed from the DOM (Optional. Default `true`).\r\n   */\r\n  public destroy(removeDOM = true): GridStack {\r\n    if (!this.el) return; // prevent multiple calls\r\n    this._updateWindowResizeEvent(true);\r\n    this.setStatic(true, false); // permanently removes DD but don't set CSS class (we're going away)\r\n    this.setAnimation(false);\r\n    if (!removeDOM) {\r\n      this.removeAll(removeDOM);\r\n      this.el.classList.remove(this._styleSheetClass);\r\n    } else {\r\n      this.el.parentNode.removeChild(this.el);\r\n    }\r\n    this._removeStylesheet();\r\n    this.el.removeAttribute('gs-current-row');\r\n    delete this.parentGridItem;\r\n    delete this.opts;\r\n    delete this._placeholder;\r\n    delete this.engine;\r\n    delete this.el.gridstack; // remove circular dependency that would prevent a freeing\r\n    delete this.el;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * enable/disable floating widgets (default: `false`) See [example](http://gridstackjs.com/demo/float.html)\r\n   */\r\n  public float(val: boolean): GridStack {\r\n    if (this.opts.float !== val) {\r\n      this.opts.float = this.engine.float = val;\r\n      this._triggerChangeEvent();\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * get the current float mode\r\n   */\r\n  public getFloat(): boolean {\r\n    return this.engine.float;\r\n  }\r\n\r\n  /**\r\n   * Get the position of the cell under a pixel on screen.\r\n   * @param position the position of the pixel to resolve in\r\n   * absolute coordinates, as an object with top and left properties\r\n   * @param useDocRelative if true, value will be based on document position vs parent position (Optional. Default false).\r\n   * Useful when grid is within `position: relative` element\r\n   *\r\n   * Returns an object with properties `x` and `y` i.e. the column and row in the grid.\r\n   */\r\n  public getCellFromPixel(position: MousePosition, useDocRelative = false): CellPosition {\r\n    let box = this.el.getBoundingClientRect();\r\n    // console.log(`getBoundingClientRect left: ${box.left} top: ${box.top} w: ${box.w} h: ${box.h}`)\r\n    let containerPos: {top: number, left: number};\r\n    if (useDocRelative) {\r\n      containerPos = {top: box.top + document.documentElement.scrollTop, left: box.left};\r\n      // console.log(`getCellFromPixel scrollTop: ${document.documentElement.scrollTop}`)\r\n    } else {\r\n      containerPos = {top: this.el.offsetTop, left: this.el.offsetLeft}\r\n      // console.log(`getCellFromPixel offsetTop: ${containerPos.left} offsetLeft: ${containerPos.top}`)\r\n    }\r\n    let relativeLeft = position.left - containerPos.left;\r\n    let relativeTop = position.top - containerPos.top;\r\n\r\n    let columnWidth = (box.width / this.getColumn());\r\n    let rowHeight = (box.height / parseInt(this.el.getAttribute('gs-current-row')));\r\n\r\n    return {x: Math.floor(relativeLeft / columnWidth), y: Math.floor(relativeTop / rowHeight)};\r\n  }\r\n\r\n  /** returns the current number of rows, which will be at least `minRow` if set */\r\n  public getRow(): number {\r\n    return Math.max(this.engine.getRow(), this.opts.minRow);\r\n  }\r\n\r\n  /**\r\n   * Checks if specified area is empty.\r\n   * @param x the position x.\r\n   * @param y the position y.\r\n   * @param w the width of to check\r\n   * @param h the height of to check\r\n   */\r\n  public isAreaEmpty(x: number, y: number, w: number, h: number): boolean {\r\n    return this.engine.isAreaEmpty(x, y, w, h);\r\n  }\r\n\r\n  /**\r\n   * If you add elements to your grid by hand, you have to tell gridstack afterwards to make them widgets.\r\n   * If you want gridstack to add the elements for you, use `addWidget()` instead.\r\n   * Makes the given element a widget and returns it.\r\n   * @param els widget or single selector to convert.\r\n   *\r\n   * @example\r\n   * let grid = GridStack.init();\r\n   * grid.el.appendChild('<div id=\"gsi-1\" gs-w=\"3\"></div>');\r\n   * grid.makeWidget('#gsi-1');\r\n   */\r\n  public makeWidget(els: GridStackElement): GridItemHTMLElement {\r\n    let el = GridStack.getElement(els);\r\n    this._prepareElement(el, true);\r\n    this._updateContainerHeight();\r\n    this._triggerAddEvent();\r\n    this._triggerChangeEvent();\r\n    return el;\r\n  }\r\n\r\n  /**\r\n   * Event handler that extracts our CustomEvent data out automatically for receiving custom\r\n   * notifications (see doc for supported events)\r\n   * @param name of the event (see possible values) or list of names space separated\r\n   * @param callback function called with event and optional second/third param\r\n   * (see README documentation for each signature).\r\n   *\r\n   * @example\r\n   * grid.on('added', function(e, items) { log('added ', items)} );\r\n   * or\r\n   * grid.on('added removed change', function(e, items) { log(e.type, items)} );\r\n   *\r\n   * Note: in some cases it is the same as calling native handler and parsing the event.\r\n   * grid.el.addEventListener('added', function(event) { log('added ', event.detail)} );\r\n   *\r\n   */\r\n  public on(name: GridStackEvent, callback: GridStackEventHandlerCallback): GridStack {\r\n    // check for array of names being passed instead\r\n    if (name.indexOf(' ') !== -1) {\r\n      let names = name.split(' ') as GridStackEvent[];\r\n      names.forEach(name => this.on(name, callback));\r\n      return this;\r\n    }\r\n\r\n    if (name === 'change' || name === 'added' || name === 'removed' || name === 'enable' || name === 'disable') {\r\n      // native CustomEvent handlers - cash the generic handlers so we can easily remove\r\n      let noData = (name === 'enable' || name === 'disable');\r\n      if (noData) {\r\n        this._gsEventHandler[name] = (event: Event) => (callback as GridStackEventHandler)(event);\r\n      } else {\r\n        this._gsEventHandler[name] = (event: CustomEvent) => (callback as GridStackNodesHandler)(event, event.detail);\r\n      }\r\n      this.el.addEventListener(name, this._gsEventHandler[name]);\r\n    } else if (name === 'drag' || name === 'dragstart' || name === 'dragstop' || name === 'resizestart' || name === 'resize' || name === 'resizestop' || name === 'dropped') {\r\n      // drag&drop stop events NEED to be call them AFTER we update node attributes so handle them ourself.\r\n      // do same for start event to make it easier...\r\n      this._gsEventHandler[name] = callback;\r\n    } else {\r\n      console.log('GridStack.on(' + name + ') event not supported, but you can still use $(\".grid-stack\").on(...) while jquery-ui is still used internally.');\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * unsubscribe from the 'on' event below\r\n   * @param name of the event (see possible values)\r\n   */\r\n  public off(name: GridStackEvent): GridStack {\r\n    // check for array of names being passed instead\r\n    if (name.indexOf(' ') !== -1) {\r\n      let names = name.split(' ') as GridStackEvent[];\r\n      names.forEach(name => this.off(name));\r\n      return this;\r\n    }\r\n\r\n    if (name === 'change' || name === 'added' || name === 'removed' || name === 'enable' || name === 'disable') {\r\n      // remove native CustomEvent handlers\r\n      if (this._gsEventHandler[name]) {\r\n        this.el.removeEventListener(name, this._gsEventHandler[name]);\r\n      }\r\n    }\r\n    delete this._gsEventHandler[name];\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes widget from the grid.\r\n   * @param el  widget or selector to modify\r\n   * @param removeDOM if `false` DOM element won't be removed from the tree (Default? true).\r\n   * @param triggerEvent if `false` (quiet mode) element will not be added to removed list and no 'removed' callbacks will be called (Default? true).\r\n   */\r\n  public removeWidget(els: GridStackElement, removeDOM = true, triggerEvent = true): GridStack {\r\n    GridStack.getElements(els).forEach(el => {\r\n      if (el.parentElement && el.parentElement !== this.el) return; // not our child!\r\n      let node = el.gridstackNode;\r\n      // For Meteor support: https://github.com/gridstack/gridstack.js/pull/272\r\n      if (!node) {\r\n        node = this.engine.nodes.find(n => el === n.el);\r\n      }\r\n      if (!node) return;\r\n\r\n      // remove our DOM data (circular link) and drag&drop permanently\r\n      delete el.gridstackNode;\r\n      this._removeDD(el);\r\n\r\n      this.engine.removeNode(node, removeDOM, triggerEvent);\r\n\r\n      if (removeDOM && el.parentElement) {\r\n        el.remove(); // in batch mode engine.removeNode doesn't call back to remove DOM\r\n      }\r\n    });\r\n    if (triggerEvent) {\r\n      this._triggerRemoveEvent();\r\n      this._triggerChangeEvent();\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes all widgets from the grid.\r\n   * @param removeDOM if `false` DOM elements won't be removed from the tree (Default? `true`).\r\n   */\r\n  public removeAll(removeDOM = true): GridStack {\r\n    // always remove our DOM data (circular link) before list gets emptied and drag&drop permanently\r\n    this.engine.nodes.forEach(n => {\r\n      delete n.el.gridstackNode;\r\n      this._removeDD(n.el);\r\n    });\r\n    this.engine.removeAll(removeDOM);\r\n    this._triggerRemoveEvent();\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Toggle the grid animation state.  Toggles the `grid-stack-animate` class.\r\n   * @param doAnimate if true the grid will animate.\r\n   */\r\n  public setAnimation(doAnimate: boolean): GridStack {\r\n    if (doAnimate) {\r\n      this.el.classList.add('grid-stack-animate');\r\n    } else {\r\n      this.el.classList.remove('grid-stack-animate');\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Toggle the grid static state, which permanently removes/add Drag&Drop support, unlike disable()/enable() that just turns it off/on.\r\n   * Also toggle the grid-stack-static class.\r\n   * @param val if true the grid become static.\r\n   * @param updateClass true (default) if css class gets updated\r\n   * @param recurse true (default) if sub-grids also get updated\r\n   */\r\n  public setStatic(val: boolean, updateClass = true, recurse = true): GridStack {\r\n    if (this.opts.staticGrid === val) return this;\r\n    this.opts.staticGrid = val;\r\n    this._setupRemoveDrop();\r\n    this._setupAcceptWidget();\r\n    this.engine.nodes.forEach(n => {\r\n      this._prepareDragDropByNode(n); // either delete or init Drag&drop\r\n      if (n.subGrid && recurse) (n.subGrid as GridStack).setStatic(val, updateClass, recurse);\r\n    });\r\n    if (updateClass) { this._setStaticClass(); }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Updates widget position/size and other info. Note: if you need to call this on all nodes, use load() instead which will update what changed.\r\n   * @param els  widget or selector of objects to modify (note: setting the same x,y for multiple items will be indeterministic and likely unwanted)\r\n   * @param opt new widget options (x,y,w,h, etc..). Only those set will be updated.\r\n   */\r\n  public update(els: GridStackElement, opt: GridStackWidget): GridStack {\r\n\r\n    // support legacy call for now ?\r\n    if (arguments.length > 2) {\r\n      console.warn('gridstack.ts: `update(el, x, y, w, h)` is deprecated. Use `update(el, {x, w, content, ...})`. It will be removed soon');\r\n      // eslint-disable-next-line prefer-rest-params\r\n      let a = arguments, i = 1;\r\n      opt = { x:a[i++], y:a[i++], w:a[i++], h:a[i++] };\r\n      return this.update(els, opt);\r\n    }\r\n\r\n    GridStack.getElements(els).forEach(el => {\r\n      if (!el || !el.gridstackNode) return;\r\n      let n = el.gridstackNode;\r\n      let w = Utils.cloneDeep(opt); // make a copy we can modify in case they re-use it or multiple items\r\n      delete w.autoPosition;\r\n\r\n      // move/resize widget if anything changed\r\n      let keys = ['x', 'y', 'w', 'h'];\r\n      let m: GridStackWidget;\r\n      if (keys.some(k => w[k] !== undefined && w[k] !== n[k])) {\r\n        m = {};\r\n        keys.forEach(k => {\r\n          m[k] = (w[k] !== undefined) ? w[k] : n[k];\r\n          delete w[k];\r\n        });\r\n      }\r\n      // for a move as well IFF there is any min/max fields set\r\n      if (!m && (w.minW || w.minH || w.maxW || w.maxH)) {\r\n        m = {}; // will use node position but validate values\r\n      }\r\n\r\n      // check for content changing\r\n      if (w.content) {\r\n        let sub = el.querySelector('.grid-stack-item-content');\r\n        if (sub && sub.innerHTML !== w.content) {\r\n          sub.innerHTML = w.content;\r\n        }\r\n        delete w.content;\r\n      }\r\n\r\n      // any remaining fields are assigned, but check for dragging changes, resize constrain\r\n      let changed = false;\r\n      let ddChanged = false;\r\n      for (const key in w) {\r\n        if (key[0] !== '_' && n[key] !== w[key]) {\r\n          n[key] = w[key];\r\n          changed = true;\r\n          ddChanged = ddChanged || (!this.opts.staticGrid && (key === 'noResize' || key === 'noMove' || key === 'locked'));\r\n        }\r\n      }\r\n\r\n      // finally move the widget\r\n      if (m) {\r\n        this.engine.cleanNodes()\r\n          .beginUpdate(n)\r\n          .moveNode(n, m);\r\n        this._updateContainerHeight();\r\n        this._triggerChangeEvent();\r\n        this.engine.endUpdate();\r\n      }\r\n      if (changed) { // move will only update x,y,w,h so update the rest too\r\n        this._writeAttr(el, n);\r\n      }\r\n      if (ddChanged) {\r\n        this._prepareDragDropByNode(n);\r\n      }\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Updates the margins which will set all 4 sides at once - see `GridStackOptions.margin` for format options (CSS string format of 1,2,4 values or single number).\r\n   * @param value margin value\r\n   */\r\n  public margin(value: numberOrString): GridStack {\r\n    let isMultiValue = (typeof value === 'string' && value.split(' ').length > 1);\r\n    // check if we can skip re-creating our CSS file... won't check if multi values (too much hassle)\r\n    if (!isMultiValue) {\r\n      let data = Utils.parseHeight(value);\r\n      if (this.opts.marginUnit === data.unit && this.opts.margin === data.h) return;\r\n    }\r\n    // re-use existing margin handling\r\n    this.opts.margin = value;\r\n    this.opts.marginTop = this.opts.marginBottom = this.opts.marginLeft = this.opts.marginRight = undefined;\r\n    this._initMargin();\r\n\r\n    this._updateStyles(true); // true = force re-create\r\n\r\n    return this;\r\n  }\r\n\r\n  /** returns current margin number value (undefined if 4 sides don't match) */\r\n  public getMargin(): number { return this.opts.margin as number; }\r\n\r\n  /**\r\n   * Returns true if the height of the grid will be less than the vertical\r\n   * constraint. Always returns true if grid doesn't have height constraint.\r\n   * @param node contains x,y,w,h,auto-position options\r\n   *\r\n   * @example\r\n   * if (grid.willItFit(newWidget)) {\r\n   *   grid.addWidget(newWidget);\r\n   * } else {\r\n   *   alert('Not enough free space to place the widget');\r\n   * }\r\n   */\r\n  public willItFit(node: GridStackWidget): boolean {\r\n    // support legacy call for now\r\n    if (arguments.length > 1) {\r\n      console.warn('gridstack.ts: `willItFit(x,y,w,h,autoPosition)` is deprecated. Use `willItFit({x, y,...})`. It will be removed soon');\r\n      // eslint-disable-next-line prefer-rest-params\r\n      let a = arguments, i = 0,\r\n        w: GridStackWidget = { x:a[i++], y:a[i++], w:a[i++], h:a[i++], autoPosition:a[i++] };\r\n      return this.willItFit(w);\r\n    }\r\n    return this.engine.willItFit(node);\r\n  }\r\n\r\n  /** @internal */\r\n  protected _triggerChangeEvent(): GridStack {\r\n    if (this.engine.batchMode) return this;\r\n    let elements = this.engine.getDirtyNodes(true); // verify they really changed\r\n    if (elements && elements.length) {\r\n      if (!this._ignoreLayoutsNodeChange) {\r\n        this.engine.layoutsNodesChange(elements);\r\n      }\r\n      this._triggerEvent('change', elements);\r\n    }\r\n    this.engine.saveInitial(); // we called, now reset initial values & dirty flags\r\n    return this;\r\n  }\r\n\r\n  /** @internal */\r\n  protected _triggerAddEvent(): GridStack {\r\n    if (this.engine.batchMode) return this;\r\n    if (this.engine.addedNodes && this.engine.addedNodes.length > 0) {\r\n      if (!this._ignoreLayoutsNodeChange) {\r\n        this.engine.layoutsNodesChange(this.engine.addedNodes);\r\n      }\r\n      // prevent added nodes from also triggering 'change' event (which is called next)\r\n      this.engine.addedNodes.forEach(n => { delete n._dirty; });\r\n      this._triggerEvent('added', this.engine.addedNodes);\r\n      this.engine.addedNodes = [];\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** @internal */\r\n  public _triggerRemoveEvent(): GridStack {\r\n    if (this.engine.batchMode) return this;\r\n    if (this.engine.removedNodes && this.engine.removedNodes.length > 0) {\r\n      this._triggerEvent('removed', this.engine.removedNodes);\r\n      this.engine.removedNodes = [];\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** @internal */\r\n  protected _triggerEvent(type: string, data?: GridStackNode[]): GridStack {\r\n    let event = data ? new CustomEvent(type, {bubbles: false, detail: data}) : new Event(type);\r\n    this.el.dispatchEvent(event);\r\n    return this;\r\n  }\r\n\r\n  /** @internal called to delete the current dynamic style sheet used for our layout */\r\n  protected _removeStylesheet(): GridStack {\r\n\r\n    if (this._styles) {\r\n      Utils.removeStylesheet(this._styleSheetClass);\r\n      delete this._styles;\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** @internal updated/create the CSS styles for row based layout and initial margin setting */\r\n  protected _updateStyles(forceUpdate = false, maxH?: number): GridStack {\r\n    // call to delete existing one if we change cellHeight / margin\r\n    if (forceUpdate) {\r\n      this._removeStylesheet();\r\n    }\r\n\r\n    if (!maxH) maxH = this.getRow();\r\n    this._updateContainerHeight();\r\n\r\n    // if user is telling us they will handle the CSS themselves by setting heights to 0. Do we need this opts really ??\r\n    if (this.opts.cellHeight === 0) {\r\n      return this;\r\n    }\r\n\r\n    let cellHeight = this.opts.cellHeight as number;\r\n    let cellHeightUnit = this.opts.cellHeightUnit;\r\n    let prefix = `.${this._styleSheetClass} > .${this.opts.itemClass}`;\r\n\r\n    // create one as needed\r\n    if (!this._styles) {\r\n      // insert style to parent (instead of 'head' by default) to support WebComponent\r\n      let styleLocation = this.opts.styleInHead ? undefined : this.el.parentNode as HTMLElement;\r\n      this._styles = Utils.createStylesheet(this._styleSheetClass, styleLocation);\r\n      if (!this._styles) return this;\r\n      this._styles._max = 0;\r\n\r\n      // these are done once only\r\n      Utils.addCSSRule(this._styles, prefix, `min-height: ${cellHeight}${cellHeightUnit}`);\r\n      // content margins\r\n      let top: string = this.opts.marginTop + this.opts.marginUnit;\r\n      let bottom: string = this.opts.marginBottom + this.opts.marginUnit;\r\n      let right: string = this.opts.marginRight + this.opts.marginUnit;\r\n      let left: string = this.opts.marginLeft + this.opts.marginUnit;\r\n      let content = `${prefix} > .grid-stack-item-content`;\r\n      let placeholder = `.${this._styleSheetClass} > .grid-stack-placeholder > .placeholder-content`;\r\n      Utils.addCSSRule(this._styles, content, `top: ${top}; right: ${right}; bottom: ${bottom}; left: ${left};`);\r\n      Utils.addCSSRule(this._styles, placeholder, `top: ${top}; right: ${right}; bottom: ${bottom}; left: ${left};`);\r\n      // resize handles offset (to match margin)\r\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-ne`, `right: ${right}`);\r\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-e`, `right: ${right}`);\r\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-se`, `right: ${right}; bottom: ${bottom}`);\r\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-nw`, `left: ${left}`);\r\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-w`, `left: ${left}`);\r\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-sw`, `left: ${left}; bottom: ${bottom}`);\r\n    }\r\n\r\n    // now update the height specific fields\r\n    maxH = maxH || this._styles._max;\r\n    if (maxH > this._styles._max) {\r\n      let getHeight = (rows: number): string => (cellHeight * rows) + cellHeightUnit;\r\n      for (let i = this._styles._max + 1; i <= maxH; i++) { // start at 1\r\n        let h: string = getHeight(i);\r\n        Utils.addCSSRule(this._styles, `${prefix}[gs-y=\"${i-1}\"]`,   `top: ${getHeight(i-1)}`); // start at 0\r\n        Utils.addCSSRule(this._styles, `${prefix}[gs-h=\"${i}\"]`,     `height: ${h}`);\r\n        Utils.addCSSRule(this._styles, `${prefix}[gs-min-h=\"${i}\"]`, `min-height: ${h}`);\r\n        Utils.addCSSRule(this._styles, `${prefix}[gs-max-h=\"${i}\"]`, `max-height: ${h}`);\r\n      }\r\n      this._styles._max = maxH;\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** @internal */\r\n  protected _updateContainerHeight(): GridStack {\r\n    if (!this.engine || this.engine.batchMode) return this;\r\n    let row = this.getRow() + this._extraDragRow; // checks for minRow already\r\n    // check for css min height\r\n    // Note: we don't handle %,rem correctly so comment out, beside we don't need need to create un-necessary\r\n    // rows as the CSS will make us bigger than our set height if needed... not sure why we had this.\r\n    // let cssMinHeight = parseInt(getComputedStyle(this.el)['min-height']);\r\n    // if (cssMinHeight > 0) {\r\n    //   let minRow = Math.round(cssMinHeight / this.getCellHeight(true));\r\n    //   if (row < minRow) {\r\n    //     row = minRow;\r\n    //   }\r\n    // }\r\n    this.el.setAttribute('gs-current-row', String(row));\r\n    if (row === 0) {\r\n      this.el.style.removeProperty('min-height');\r\n      return this;\r\n    }\r\n    let cellHeight = this.opts.cellHeight as number;\r\n    let unit = this.opts.cellHeightUnit;\r\n    if (!cellHeight) return this;\r\n    this.el.style.minHeight = row * cellHeight + unit;\r\n    return this;\r\n  }\r\n\r\n  /** @internal */\r\n  protected _prepareElement(el: GridItemHTMLElement, triggerAddEvent = false, node?: GridStackNode): GridStack {\r\n    el.classList.add(this.opts.itemClass);\r\n    node = node || this._readAttr(el);\r\n    el.gridstackNode = node;\r\n    node.el = el;\r\n    node.grid = this;\r\n    let copy = {...node};\r\n    node = this.engine.addNode(node, triggerAddEvent);\r\n    // write node attr back in case there was collision or we have to fix bad values during addNode()\r\n    if (!Utils.same(node, copy)) {\r\n      this._writeAttr(el, node);\r\n    }\r\n    this._prepareDragDropByNode(node);\r\n    return this;\r\n  }\r\n\r\n  /** @internal call to write position x,y,w,h attributes back to element */\r\n  protected _writePosAttr(el: HTMLElement, n: GridStackPosition): GridStack {\r\n    if (n.x !== undefined && n.x !== null) { el.setAttribute('gs-x', String(n.x)); }\r\n    if (n.y !== undefined && n.y !== null) { el.setAttribute('gs-y', String(n.y)); }\r\n    if (n.w) { el.setAttribute('gs-w', String(n.w)); }\r\n    if (n.h) { el.setAttribute('gs-h', String(n.h)); }\r\n    return this;\r\n  }\r\n\r\n  /** @internal call to write any default attributes back to element */\r\n  protected _writeAttr(el: HTMLElement, node: GridStackWidget): GridStack {\r\n    if (!node) return this;\r\n    this._writePosAttr(el, node);\r\n\r\n    let attrs /*: GridStackWidget but strings */ = { // remaining attributes\r\n      autoPosition: 'gs-auto-position',\r\n      minW: 'gs-min-w',\r\n      minH: 'gs-min-h',\r\n      maxW: 'gs-max-w',\r\n      maxH: 'gs-max-h',\r\n      noResize: 'gs-no-resize',\r\n      noMove: 'gs-no-move',\r\n      locked: 'gs-locked',\r\n      id: 'gs-id',\r\n    };\r\n    for (const key in attrs) {\r\n      if (node[key]) { // 0 is valid for x,y only but done above already and not in list anyway\r\n        el.setAttribute(attrs[key], String(node[key]));\r\n      } else {\r\n        el.removeAttribute(attrs[key]);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** @internal call to read any default attributes from element */\r\n  protected _readAttr(el: HTMLElement): GridStackWidget {\r\n    let node: GridStackNode = {};\r\n    node.x = Utils.toNumber(el.getAttribute('gs-x'));\r\n    node.y = Utils.toNumber(el.getAttribute('gs-y'));\r\n    node.w = Utils.toNumber(el.getAttribute('gs-w'));\r\n    node.h = Utils.toNumber(el.getAttribute('gs-h'));\r\n    node.maxW = Utils.toNumber(el.getAttribute('gs-max-w'));\r\n    node.minW = Utils.toNumber(el.getAttribute('gs-min-w'));\r\n    node.maxH = Utils.toNumber(el.getAttribute('gs-max-h'));\r\n    node.minH = Utils.toNumber(el.getAttribute('gs-min-h'));\r\n    node.autoPosition = Utils.toBool(el.getAttribute('gs-auto-position'));\r\n    node.noResize = Utils.toBool(el.getAttribute('gs-no-resize'));\r\n    node.noMove = Utils.toBool(el.getAttribute('gs-no-move'));\r\n    node.locked = Utils.toBool(el.getAttribute('gs-locked'));\r\n    node.id = el.getAttribute('gs-id');\r\n\r\n    // remove any key not found (null or false which is default)\r\n    for (const key in node) {\r\n      if (!node.hasOwnProperty(key)) return;\r\n      if (!node[key] && node[key] !== 0) { // 0 can be valid value (x,y only really)\r\n        delete node[key];\r\n      }\r\n    }\r\n\r\n    return node;\r\n  }\r\n\r\n  /** @internal */\r\n  protected _setStaticClass(): GridStack {\r\n    let classes = ['grid-stack-static'];\r\n\r\n    if (this.opts.staticGrid) {\r\n      this.el.classList.add(...classes);\r\n      this.el.setAttribute('gs-static', 'true');\r\n    } else {\r\n      this.el.classList.remove(...classes);\r\n      this.el.removeAttribute('gs-static');\r\n\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * called when we are being resized by the window - check if the one Column Mode needs to be turned on/off\r\n   * and remember the prev columns we used, or get our count from parent, as well as check for auto cell height (square)\r\n   */\r\n  public onParentResize(): GridStack {\r\n    if (!this.el || !this.el.clientWidth) return; // return if we're gone or no size yet (will get called again)\r\n    let changedColumn = false;\r\n\r\n    // see if we're nested and take our column count from our parent....\r\n    if (this._autoColumn && this.parentGridItem) {\r\n      if (this.opts.column !== this.parentGridItem.w) {\r\n        changedColumn = true;\r\n        this.column(this.parentGridItem.w, 'none');\r\n      }\r\n    } else {\r\n      // else check for 1 column in/out behavior\r\n      let oneColumn = !this.opts.disableOneColumnMode && this.el.clientWidth <= this.opts.oneColumnSize;\r\n      if ((this.opts.column === 1) !== oneColumn) {\r\n        changedColumn = true;\r\n        if (this.opts.animate) { this.setAnimation(false); } // 1 <-> 12 is too radical, turn off animation\r\n        this.column(oneColumn ? 1 : this._prevColumn);\r\n        if (this.opts.animate) { this.setAnimation(true); }\r\n      }\r\n    }\r\n\r\n    // make the cells content square again\r\n    if (this._isAutoCellHeight) {\r\n      if (!changedColumn && this.opts.cellHeightThrottle) {\r\n        if (!this._cellHeightThrottle) {\r\n          this._cellHeightThrottle = Utils.throttle(() => this.cellHeight(), this.opts.cellHeightThrottle);\r\n        }\r\n        this._cellHeightThrottle();\r\n      } else {\r\n        // immediate update if we've changed column count or have no threshold\r\n        this.cellHeight();\r\n      }\r\n    }\r\n\r\n    // finally update any nested grids\r\n    this.engine.nodes.forEach(n => {\r\n      if (n.subGrid) {(n.subGrid as GridStack).onParentResize()}\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  /** add or remove the window size event handler */\r\n  protected _updateWindowResizeEvent(forceRemove = false): GridStack {\r\n    // only add event if we're not nested (parent will call us) and we're auto sizing cells or supporting oneColumn (i.e. doing work)\r\n    const workTodo = (this._isAutoCellHeight || !this.opts.disableOneColumnMode) && !this.parentGridItem;\r\n\r\n    if (!forceRemove && workTodo && !this._windowResizeBind) {\r\n      this._windowResizeBind = this.onParentResize.bind(this); // so we can properly remove later\r\n      window.addEventListener('resize', this._windowResizeBind);\r\n    } else if ((forceRemove || !workTodo) && this._windowResizeBind) {\r\n      window.removeEventListener('resize', this._windowResizeBind);\r\n      delete this._windowResizeBind; // remove link to us so we can free\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /** @internal convert a potential selector into actual element */\r\n  public static getElement(els: GridStackElement = '.grid-stack-item'): GridItemHTMLElement { return Utils.getElement(els) }\r\n  /** @internal */\r\n  public static getElements(els: GridStackElement = '.grid-stack-item'): GridItemHTMLElement[] { return Utils.getElements(els) }\r\n  /** @internal */\r\n  public static getGridElement(els: GridStackElement): GridHTMLElement { return GridStack.getElement(els) }\r\n  /** @internal */\r\n  public static getGridElements(els: string): GridHTMLElement[] { return Utils.getElements(els) }\r\n\r\n  /** @internal initialize margin top/bottom/left/right and units */\r\n  protected _initMargin(): GridStack {\r\n\r\n    let data: HeightData;\r\n    let margin = 0;\r\n\r\n    // support passing multiple values like CSS (ex: '5px 10px 0 20px')\r\n    let margins: string[] = [];\r\n    if (typeof this.opts.margin === 'string') {\r\n      margins = this.opts.margin.split(' ')\r\n    }\r\n    if (margins.length === 2) { // top/bot, left/right like CSS\r\n      this.opts.marginTop = this.opts.marginBottom = margins[0];\r\n      this.opts.marginLeft = this.opts.marginRight = margins[1];\r\n    } else if (margins.length === 4) { // Clockwise like CSS\r\n      this.opts.marginTop = margins[0];\r\n      this.opts.marginRight = margins[1];\r\n      this.opts.marginBottom = margins[2];\r\n      this.opts.marginLeft = margins[3];\r\n    } else {\r\n      data = Utils.parseHeight(this.opts.margin);\r\n      this.opts.marginUnit = data.unit;\r\n      margin = this.opts.margin = data.h;\r\n    }\r\n\r\n    // see if top/bottom/left/right need to be set as well\r\n    if (this.opts.marginTop === undefined) {\r\n      this.opts.marginTop = margin;\r\n    } else {\r\n      data = Utils.parseHeight(this.opts.marginTop);\r\n      this.opts.marginTop = data.h;\r\n      delete this.opts.margin;\r\n    }\r\n\r\n    if (this.opts.marginBottom === undefined) {\r\n      this.opts.marginBottom = margin;\r\n    } else {\r\n      data = Utils.parseHeight(this.opts.marginBottom);\r\n      this.opts.marginBottom = data.h;\r\n      delete this.opts.margin;\r\n    }\r\n\r\n    if (this.opts.marginRight === undefined) {\r\n      this.opts.marginRight = margin;\r\n    } else {\r\n      data = Utils.parseHeight(this.opts.marginRight);\r\n      this.opts.marginRight = data.h;\r\n      delete this.opts.margin;\r\n    }\r\n\r\n    if (this.opts.marginLeft === undefined) {\r\n      this.opts.marginLeft = margin;\r\n    } else {\r\n      data = Utils.parseHeight(this.opts.marginLeft);\r\n      this.opts.marginLeft = data.h;\r\n      delete this.opts.margin;\r\n    }\r\n    this.opts.marginUnit = data.unit; // in case side were spelled out, use those units instead...\r\n    if (this.opts.marginTop === this.opts.marginBottom && this.opts.marginLeft === this.opts.marginRight && this.opts.marginTop === this.opts.marginRight) {\r\n      this.opts.margin = this.opts.marginTop; // makes it easier to check for no-ops in setMargin()\r\n    }\r\n    return this;\r\n  }\r\n\r\n  static GDRev = '7.2.3';\r\n\r\n  /* ===========================================================================================\r\n   * drag&drop methods that used to be stubbed out and implemented in dd-gridstack.ts\r\n   * but caused loading issues in prod - see https://github.com/gridstack/gridstack.js/issues/2039\r\n   * ===========================================================================================\r\n   */\r\n\r\n  /** get the global (but static to this code) DD implementation */\r\n  public static getDD(): DDGridStack {\r\n    return dd;\r\n  }\r\n\r\n  /**\r\n   * call to setup dragging in from the outside (say toolbar), by specifying the class selection and options.\r\n   * Called during GridStack.init() as options, but can also be called directly (last param are used) in case the toolbar\r\n   * is dynamically create and needs to be set later.\r\n   * @param dragIn string selector (ex: '.sidebar .grid-stack-item')\r\n   * @param dragInOptions options - see DDDragInOpt. (default: {handle: '.grid-stack-item-content', appendTo: 'body'}\r\n   **/\r\n  public static setupDragIn(dragIn?: string, dragInOptions?: DDDragInOpt): void {\r\n    if (dragInOptions?.pause !== undefined) {\r\n      DDManager.pauseDrag = dragInOptions.pause;\r\n    }\r\n\r\n    if (typeof dragIn === 'string') {\r\n      dragInOptions = {...dragInDefaultOptions, ...(dragInOptions || {})};\r\n      Utils.getElements(dragIn).forEach(el => {\r\n        if (!dd.isDraggable(el)) dd.dragIn(el, dragInOptions);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enables/Disables dragging by the user of specific grid element. If you want all items, and have it affect future items, use enableMove() instead. No-op for static grids.\r\n   * IF you are looking to prevent an item from moving (due to being pushed around by another during collision) use locked property instead.\r\n   * @param els widget or selector to modify.\r\n   * @param val if true widget will be draggable.\r\n   */\r\n  public movable(els: GridStackElement, val: boolean): GridStack {\r\n    if (this.opts.staticGrid) return this; // can't move a static grid!\r\n    GridStack.getElements(els).forEach(el => {\r\n      let node = el.gridstackNode;\r\n      if (!node) return;\r\n      if (val) delete node.noMove; else node.noMove = true;\r\n      this._prepareDragDropByNode(node); // init DD if need be, and adjust\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Enables/Disables user resizing of specific grid element. If you want all items, and have it affect future items, use enableResize() instead. No-op for static grids.\r\n   * @param els  widget or selector to modify\r\n   * @param val  if true widget will be resizable.\r\n   */\r\n  public resizable(els: GridStackElement, val: boolean): GridStack {\r\n    if (this.opts.staticGrid) return this; // can't resize a static grid!\r\n    GridStack.getElements(els).forEach(el => {\r\n      let node = el.gridstackNode;\r\n      if (!node) return;\r\n      if (val) delete node.noResize; else node.noResize = true;\r\n      this._prepareDragDropByNode(node); // init DD if need be, and adjust\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Temporarily disables widgets moving/resizing.\r\n   * If you want a more permanent way (which freezes up resources) use `setStatic(true)` instead.\r\n   * Note: no-op for static grid\r\n   * This is a shortcut for:\r\n   * @example\r\n   *  grid.enableMove(false);\r\n   *  grid.enableResize(false);\r\n   * @param recurse true (default) if sub-grids also get updated\r\n   */\r\n  public disable(recurse = true): GridStack {\r\n    if (this.opts.staticGrid) return;\r\n    this.enableMove(false, recurse);\r\n    this.enableResize(false, recurse);// @ts-ignore\r\n    this._triggerEvent('disable');\r\n    return this;\r\n  }\r\n  /**\r\n   * Re-enables widgets moving/resizing - see disable().\r\n   * Note: no-op for static grid.\r\n   * This is a shortcut for:\r\n   * @example\r\n   *  grid.enableMove(true);\r\n   *  grid.enableResize(true);\r\n   * @param recurse true (default) if sub-grids also get updated\r\n   */\r\n  public enable(recurse = true): GridStack {\r\n    if (this.opts.staticGrid) return;\r\n    this.enableMove(true, recurse);\r\n    this.enableResize(true, recurse);// @ts-ignore\r\n    this._triggerEvent('enable');\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Enables/disables widget moving. No-op for static grids.\r\n   * @param recurse true (default) if sub-grids also get updated\r\n   */\r\n  public enableMove(doEnable: boolean, recurse = true): GridStack {\r\n    if (this.opts.staticGrid) return this; // can't move a static grid!\r\n    this.opts.disableDrag = !doEnable; // FIRST before we update children as grid overrides #1658\r\n    this.engine.nodes.forEach(n => {\r\n      this.movable(n.el, doEnable);\r\n      if (n.subGrid && recurse) (n.subGrid as GridStack).enableMove(doEnable, recurse);\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Enables/disables widget resizing. No-op for static grids.\r\n   * @param recurse true (default) if sub-grids also get updated\r\n   */\r\n  public enableResize(doEnable: boolean, recurse = true): GridStack {\r\n    if (this.opts.staticGrid) return this; // can't size a static grid!\r\n    this.opts.disableResize = !doEnable; // FIRST before we update children as grid overrides #1658\r\n    this.engine.nodes.forEach(n => {\r\n      this.resizable(n.el, doEnable);\r\n      if (n.subGrid && recurse) (n.subGrid as GridStack).enableResize(doEnable, recurse);\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /** @internal removes any drag&drop present (called during destroy) */\r\n  protected _removeDD(el: DDElementHost): GridStack {\r\n    dd.draggable(el, 'destroy').resizable(el, 'destroy');\r\n    if (el.gridstackNode) {\r\n      delete el.gridstackNode._initDD; // reset our DD init flag\r\n    }\r\n    delete el.ddElement;\r\n    return this;\r\n  }\r\n\r\n  /** @internal called to add drag over to support widgets being added externally */\r\n  protected _setupAcceptWidget(): GridStack {\r\n\r\n    // check if we need to disable things\r\n    if (this.opts.staticGrid || (!this.opts.acceptWidgets && !this.opts.removable)) {\r\n      dd.droppable(this.el, 'destroy');\r\n      return this;\r\n    }\r\n\r\n    // vars shared across all methods\r\n    let cellHeight: number, cellWidth: number;\r\n\r\n    let onDrag = (event: DragEvent, el: GridItemHTMLElement, helper: GridItemHTMLElement) => {\r\n      let node = el.gridstackNode;\r\n      if (!node) return;\r\n\r\n      helper = helper || el;\r\n      let parent = this.el.getBoundingClientRect();\r\n      let {top, left} = helper.getBoundingClientRect();\r\n      left -= parent.left;\r\n      top -= parent.top;\r\n      let ui: DDUIData = {position: {top, left}};\r\n\r\n      if (node._temporaryRemoved) {\r\n        node.x = Math.max(0, Math.round(left / cellWidth));\r\n        node.y = Math.max(0, Math.round(top / cellHeight));\r\n        delete node.autoPosition;\r\n        this.engine.nodeBoundFix(node);\r\n\r\n        // don't accept *initial* location if doesn't fit #1419 (locked drop region, or can't grow), but maybe try if it will go somewhere\r\n        if (!this.engine.willItFit(node)) {\r\n          node.autoPosition = true; // ignore x,y and try for any slot...\r\n          if (!this.engine.willItFit(node)) {\r\n            dd.off(el, 'drag'); // stop calling us\r\n            return; // full grid or can't grow\r\n          }\r\n          if (node._willFitPos) {\r\n            // use the auto position instead #1687\r\n            Utils.copyPos(node, node._willFitPos);\r\n            delete node._willFitPos;\r\n          }\r\n        }\r\n\r\n        // re-use the existing node dragging method\r\n        this._onStartMoving(helper, event, ui, node, cellWidth, cellHeight);\r\n      } else {\r\n        // re-use the existing node dragging that does so much of the collision detection\r\n        this._dragOrResize(helper, event, ui, node, cellWidth, cellHeight);\r\n      }\r\n    }\r\n\r\n    dd.droppable(this.el, {\r\n      accept: (el: GridItemHTMLElement) => {\r\n        let node: GridStackNode = el.gridstackNode;\r\n        // set accept drop to true on ourself (which we ignore) so we don't get \"can't drop\" icon in HTML5 mode while moving\r\n        if (node?.grid === this) return true;\r\n        if (!this.opts.acceptWidgets) return false;\r\n        // check for accept method or class matching\r\n        let canAccept = true;\r\n        if (typeof this.opts.acceptWidgets === 'function') {\r\n          canAccept = this.opts.acceptWidgets(el);\r\n        } else {\r\n          let selector = (this.opts.acceptWidgets === true ? '.grid-stack-item' : this.opts.acceptWidgets as string);\r\n          canAccept = el.matches(selector);\r\n        }\r\n        // finally check to make sure we actually have space left #1571\r\n        if (canAccept && node && this.opts.maxRow) {\r\n          let n = {w: node.w, h: node.h, minW: node.minW, minH: node.minH}; // only width/height matters and autoPosition\r\n          canAccept = this.engine.willItFit(n);\r\n        }\r\n        return canAccept;\r\n      }\r\n    })\r\n    /**\r\n     * entering our grid area\r\n     */\r\n      .on(this.el, 'dropover', (event: Event, el: GridItemHTMLElement, helper: GridItemHTMLElement) => {\r\n      // console.log(`over ${this.el.gridstack.opts.id} ${count++}`); // TEST\r\n        let node = el.gridstackNode;\r\n        // ignore drop enter on ourself (unless we temporarily removed) which happens on a simple drag of our item\r\n        if (node?.grid === this && !node._temporaryRemoved) {\r\n        // delete node._added; // reset this to track placeholder again in case we were over other grid #1484 (dropout doesn't always clear)\r\n          return false; // prevent parent from receiving msg (which may be a grid as well)\r\n        }\r\n\r\n        // fix #1578 when dragging fast, we may not get a leave on the previous grid so force one now\r\n        if (node?.grid && node.grid !== this && !node._temporaryRemoved) {\r\n        // console.log('dropover without leave'); // TEST\r\n          let otherGrid = node.grid;\r\n          otherGrid._leave(el, helper);\r\n        }\r\n\r\n        // cache cell dimensions (which don't change), position can animate if we removed an item in otherGrid that affects us...\r\n        cellWidth = this.cellWidth();\r\n        cellHeight = this.getCellHeight(true);\r\n\r\n        // load any element attributes if we don't have a node\r\n        if (!node) {// @ts-ignore private read only on ourself\r\n          node = this._readAttr(el);\r\n        }\r\n        if (!node.grid) {\r\n          node._isExternal = true;\r\n          el.gridstackNode = node;\r\n        }\r\n\r\n        // calculate the grid size based on element outer size\r\n        helper = helper || el;\r\n        let w = node.w || Math.round(helper.offsetWidth / cellWidth) || 1;\r\n        let h = node.h || Math.round(helper.offsetHeight / cellHeight) || 1;\r\n\r\n        // if the item came from another grid, make a copy and save the original info in case we go back there\r\n        if (node.grid && node.grid !== this) {\r\n        // copy the node original values (min/max/id/etc...) but override width/height/other flags which are this grid specific\r\n        // console.log('dropover cloning node'); // TEST\r\n          if (!el._gridstackNodeOrig) el._gridstackNodeOrig = node; // shouldn't have multiple nested!\r\n          el.gridstackNode = node = {...node, w, h, grid: this};\r\n          this.engine.cleanupNode(node)\r\n            .nodeBoundFix(node);\r\n          // restore some internal fields we need after clearing them all\r\n          node._initDD =\r\n        node._isExternal =  // DOM needs to be re-parented on a drop\r\n        node._temporaryRemoved = true; // so it can be inserted onDrag below\r\n        } else {\r\n          node.w = w; node.h = h;\r\n          node._temporaryRemoved = true; // so we can insert it\r\n        }\r\n\r\n        // clear any marked for complete removal (Note: don't check _isAboutToRemove as that is cleared above - just do it)\r\n        this._itemRemoving(node.el, false);\r\n\r\n        dd.on(el, 'drag', onDrag);\r\n        // make sure this is called at least once when going fast #1578\r\n        onDrag(event as DragEvent, el, helper);\r\n        return false; // prevent parent from receiving msg (which may be a grid as well)\r\n      })\r\n    /**\r\n     * Leaving our grid area...\r\n     */\r\n      .on(this.el, 'dropout', (event, el: GridItemHTMLElement, helper: GridItemHTMLElement) => {\r\n      // console.log(`out ${this.el.gridstack.opts.id} ${count++}`); // TEST\r\n        let node = el.gridstackNode;\r\n        if (!node) return false;\r\n        // fix #1578 when dragging fast, we might get leave after other grid gets enter (which calls us to clean)\r\n        // so skip this one if we're not the active grid really..\r\n        if (!node.grid || node.grid === this) {\r\n          this._leave(el, helper);\r\n          // if we were created as temporary nested grid, go back to before state\r\n          if (this._isTemp) {\r\n            this.removeAsSubGrid(node);\r\n          }\r\n        }\r\n        return false; // prevent parent from receiving msg (which may be grid as well)\r\n      })\r\n    /**\r\n     * end - releasing the mouse\r\n     */\r\n      .on(this.el, 'drop', (event, el: GridItemHTMLElement, helper: GridItemHTMLElement) => {\r\n        let node = el.gridstackNode;\r\n        // ignore drop on ourself from ourself that didn't come from the outside - dragend will handle the simple move instead\r\n        if (node?.grid === this && !node._isExternal) return false;\r\n\r\n        let wasAdded = !!this.placeholder.parentElement; // skip items not actually added to us because of constrains, but do cleanup #1419\r\n        this.placeholder.remove();\r\n\r\n        // notify previous grid of removal\r\n        // console.log('drop delete _gridstackNodeOrig') // TEST\r\n        let origNode = el._gridstackNodeOrig;\r\n        delete el._gridstackNodeOrig;\r\n        if (wasAdded && origNode?.grid && origNode.grid !== this) {\r\n          let oGrid = origNode.grid;\r\n          oGrid.engine.removedNodes.push(origNode);\r\n          oGrid._triggerRemoveEvent()._triggerChangeEvent();\r\n          // if it's an empty sub-grid that got auto-created, nuke it\r\n          if (oGrid.parentGridItem && !oGrid.engine.nodes.length && oGrid.opts.subGridDynamic) {\r\n            oGrid.removeAsSubGrid();\r\n          }\r\n        }\r\n\r\n        if (!node) return false;\r\n\r\n        // use existing placeholder node as it's already in our list with drop location\r\n        if (wasAdded) {\r\n          this.engine.cleanupNode(node); // removes all internal _xyz values\r\n          node.grid = this;\r\n        }\r\n        dd.off(el, 'drag');\r\n        // if we made a copy ('helper' which is temp) of the original node then insert a copy, else we move the original node (#1102)\r\n        // as the helper will be nuked by jquery-ui otherwise. TODO: update old code path\r\n        if (helper !== el) {\r\n          helper.remove();\r\n          el.gridstackNode = origNode; // original item (left behind) is re-stored to pre dragging as the node now has drop info\r\n          if (wasAdded) {\r\n            el = el.cloneNode(true) as GridItemHTMLElement;\r\n          }\r\n        } else {\r\n          el.remove(); // reduce flicker as we change depth here, and size further down\r\n          this._removeDD(el);\r\n        }\r\n        if (!wasAdded) return false;\r\n        el.gridstackNode = node;\r\n        node.el = el;\r\n        let subGrid = (node.subGrid as GridStack)?.el?.gridstack; // set when actual sub-grid present\r\n        // @ts-ignore\r\n        Utils.copyPos(node, this._readAttr(this.placeholder)); // placeholder values as moving VERY fast can throw things off #1578\r\n        Utils.removePositioningStyles(el);// @ts-ignore\r\n        this._writeAttr(el, node);\r\n        el.classList.add(gridDefaults.itemClass, this.opts.itemClass);\r\n        this.el.appendChild(el);// @ts-ignore // TODO: now would be ideal time to _removeHelperStyle() overriding floating styles (native only)\r\n        if (subGrid) {\r\n          subGrid.parentGridItem = node;\r\n          if (!subGrid.opts.styleInHead) subGrid._updateStyles(true); // re-create sub-grid styles now that we've moved\r\n        }\r\n        this._updateContainerHeight();\r\n        this.engine.addedNodes.push(node);// @ts-ignore\r\n        this._triggerAddEvent();// @ts-ignore\r\n        this._triggerChangeEvent();\r\n\r\n        this.engine.endUpdate();\r\n        if (this._gsEventHandler['dropped']) {\r\n          this._gsEventHandler['dropped']({...event, type: 'dropped'}, origNode && origNode.grid ? origNode : undefined, node);\r\n        }\r\n\r\n        // wait till we return out of the drag callback to set the new drag&resize handler or they may get messed up\r\n        window.setTimeout(() => {\r\n          // IFF we are still there (some application will use as placeholder and insert their real widget instead and better call makeWidget())\r\n          if (node.el && node.el.parentElement) {\r\n            this._prepareDragDropByNode(node);\r\n          } else {\r\n            this.engine.removeNode(node);\r\n          }\r\n          delete node.grid._isTemp;\r\n        });\r\n\r\n        return false; // prevent parent from receiving msg (which may be grid as well)\r\n      });\r\n    return this;\r\n  }\r\n\r\n  /** @internal mark item for removal */\r\n  private _itemRemoving(el: GridItemHTMLElement, remove: boolean) {\r\n    let node = el ? el.gridstackNode : undefined;\r\n    if (!node || !node.grid) return;\r\n    remove ? node._isAboutToRemove = true : delete node._isAboutToRemove;\r\n    remove ? el.classList.add('grid-stack-item-removing') : el.classList.remove('grid-stack-item-removing');\r\n  }\r\n\r\n  /** @internal called to setup a trash drop zone if the user specifies it */\r\n  protected _setupRemoveDrop(): GridStack {\r\n    if (!this.opts.staticGrid && typeof this.opts.removable === 'string') {\r\n      let trashEl = document.querySelector(this.opts.removable) as HTMLElement;\r\n      if (!trashEl) return this;\r\n      // only register ONE drop-over/dropout callback for the 'trash', and it will\r\n      // update the passed in item and parent grid because the 'trash' is a shared resource anyway,\r\n      // and Native DD only has 1 event CB (having a list and technically a per grid removableOptions complicates things greatly)\r\n      if (!dd.isDroppable(trashEl)) {\r\n        dd.droppable(trashEl, this.opts.removableOptions)\r\n          .on(trashEl, 'dropover', (event, el) => this._itemRemoving(el, true))\r\n          .on(trashEl, 'dropout',  (event, el) => this._itemRemoving(el, false));\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** @internal prepares the element for drag&drop **/\r\n  protected _prepareDragDropByNode(node: GridStackNode): GridStack {\r\n    let el = node.el;\r\n    const noMove = node.noMove || this.opts.disableDrag;\r\n    const noResize = node.noResize || this.opts.disableResize;\r\n\r\n    // check for disabled grid first\r\n    if (this.opts.staticGrid || (noMove && noResize)) {\r\n      if (node._initDD) {\r\n        this._removeDD(el); // nukes everything instead of just disable, will add some styles back next\r\n        delete node._initDD;\r\n      }\r\n      el.classList.add('ui-draggable-disabled', 'ui-resizable-disabled'); // add styles one might depend on #1435\r\n      return this;\r\n    }\r\n\r\n    if (!node._initDD) {\r\n      // variables used/cashed between the 3 start/move/end methods, in addition to node passed above\r\n      let cellWidth: number;\r\n      let cellHeight: number;\r\n\r\n      /** called when item starts moving/resizing */\r\n      let onStartMoving = (event: Event, ui: DDUIData) => {\r\n        // trigger any 'dragstart' / 'resizestart' manually\r\n        if (this._gsEventHandler[event.type]) {\r\n          this._gsEventHandler[event.type](event, event.target);\r\n        }\r\n        cellWidth = this.cellWidth();\r\n        cellHeight = this.getCellHeight(true); // force pixels for calculations\r\n\r\n        this._onStartMoving(el, event, ui, node, cellWidth, cellHeight);\r\n      }\r\n\r\n      /** called when item is being dragged/resized */\r\n      let dragOrResize = (event: MouseEvent, ui: DDUIData) => {\r\n        this._dragOrResize(el, event, ui, node, cellWidth, cellHeight);\r\n      }\r\n\r\n      /** called when the item stops moving/resizing */\r\n      let onEndMoving = (event: Event) => {\r\n        this.placeholder.remove();\r\n        delete node._moving;\r\n        delete node._event;\r\n        delete node._lastTried;\r\n\r\n        // if the item has moved to another grid, we're done here\r\n        let target: GridItemHTMLElement = event.target as GridItemHTMLElement;\r\n        if (!target.gridstackNode || target.gridstackNode.grid !== this) return;\r\n\r\n        node.el = target;\r\n\r\n        if (node._isAboutToRemove) {\r\n          let gridToNotify = el.gridstackNode.grid;\r\n          if (gridToNotify._gsEventHandler[event.type]) {\r\n            gridToNotify._gsEventHandler[event.type](event, target);\r\n          }\r\n          this._removeDD(el);\r\n          gridToNotify.engine.removedNodes.push(node);\r\n          gridToNotify._triggerRemoveEvent();\r\n          // break circular links and remove DOM\r\n          delete el.gridstackNode;\r\n          delete node.el;\r\n          el.remove();\r\n        } else {\r\n          Utils.removePositioningStyles(target);\r\n          if (node._temporaryRemoved) {\r\n            // got removed - restore item back to before dragging position\r\n            Utils.copyPos(node, node._orig);// @ts-ignore\r\n            this._writePosAttr(target, node);\r\n            this.engine.addNode(node);\r\n          } else {\r\n            // move to new placeholder location\r\n            this._writePosAttr(target, node);\r\n          }\r\n          if (this._gsEventHandler[event.type]) {\r\n            this._gsEventHandler[event.type](event, target);\r\n          }\r\n        }\r\n        // @ts-ignore\r\n        this._extraDragRow = 0;// @ts-ignore\r\n        this._updateContainerHeight();// @ts-ignore\r\n        this._triggerChangeEvent();\r\n\r\n        this.engine.endUpdate();\r\n      }\r\n\r\n      dd.draggable(el, {\r\n        start: onStartMoving,\r\n        stop: onEndMoving,\r\n        drag: dragOrResize\r\n      }).resizable(el, {\r\n        start: onStartMoving,\r\n        stop: onEndMoving,\r\n        resize: dragOrResize\r\n      });\r\n      node._initDD = true; // we've set DD support now\r\n    }\r\n\r\n    // finally fine tune move vs resize by disabling any part...\r\n    dd.draggable(el, noMove ? 'disable' : 'enable')\r\n      .resizable(el, noResize ? 'disable' : 'enable');\r\n\r\n    return this;\r\n  }\r\n\r\n  /** @internal handles actual drag/resize start **/\r\n  protected _onStartMoving(el: GridItemHTMLElement, event: Event, ui: DDUIData, node: GridStackNode, cellWidth: number, cellHeight: number): void {\r\n    this.engine.cleanNodes()\r\n      .beginUpdate(node);\r\n    // @ts-ignore\r\n    this._writePosAttr(this.placeholder, node)\r\n    this.el.appendChild(this.placeholder);\r\n    // console.log('_onStartMoving placeholder') // TEST\r\n\r\n    node.el = this.placeholder;\r\n    node._lastUiPosition = ui.position;\r\n    node._prevYPix = ui.position.top;\r\n    node._moving = (event.type === 'dragstart'); // 'dropover' are not initially moving so they can go exactly where they enter (will push stuff out of the way)\r\n    delete node._lastTried;\r\n\r\n    if (event.type === 'dropover' && node._temporaryRemoved) {\r\n      // console.log('engine.addNode x=' + node.x); // TEST\r\n      this.engine.addNode(node); // will add, fix collisions, update attr and clear _temporaryRemoved\r\n      node._moving = true; // AFTER, mark as moving object (wanted fix location before)\r\n    }\r\n\r\n    // set the min/max resize info\r\n    this.engine.cacheRects(cellWidth, cellHeight, this.opts.marginTop as number, this.opts.marginRight as number, this.opts.marginBottom as number, this.opts.marginLeft as number);\r\n    if (event.type === 'resizestart') {\r\n      dd.resizable(el, 'option', 'minWidth', cellWidth * (node.minW || 1))\r\n        .resizable(el, 'option', 'minHeight', cellHeight * (node.minH || 1));\r\n      if (node.maxW) { dd.resizable(el, 'option', 'maxWidth', cellWidth * node.maxW); }\r\n      if (node.maxH) { dd.resizable(el, 'option', 'maxHeight', cellHeight * node.maxH); }\r\n    }\r\n  }\r\n\r\n  /** @internal handles actual drag/resize **/\r\n  protected _dragOrResize(el: GridItemHTMLElement, event: MouseEvent, ui: DDUIData, node: GridStackNode, cellWidth: number, cellHeight: number): void {\r\n    let p = {...node._orig}; // could be undefined (_isExternal) which is ok (drag only set x,y and w,h will default to node value)\r\n    let resizing: boolean;\r\n    let mLeft = this.opts.marginLeft as number,\r\n      mRight = this.opts.marginRight as number,\r\n      mTop = this.opts.marginTop as number,\r\n      mBottom = this.opts.marginBottom as number;\r\n\r\n    // if margins (which are used to pass mid point by) are large relative to cell height/width, reduce them down #1855\r\n    let mHeight = Math.round(cellHeight * 0.1),\r\n      mWidth = Math.round(cellWidth * 0.1);\r\n    mLeft = Math.min(mLeft, mWidth);\r\n    mRight = Math.min(mRight, mWidth);\r\n    mTop = Math.min(mTop, mHeight);\r\n    mBottom = Math.min(mBottom, mHeight);\r\n\r\n    if (event.type === 'drag') {\r\n      if (node._temporaryRemoved) return; // handled by dropover\r\n      let distance = ui.position.top - node._prevYPix;\r\n      node._prevYPix = ui.position.top;\r\n      if (this.opts.draggable.scroll !== false) {\r\n        Utils.updateScrollPosition(el, ui.position, distance);\r\n      }\r\n\r\n      // get new position taking into account the margin in the direction we are moving! (need to pass mid point by margin)\r\n      let left = ui.position.left + (ui.position.left > node._lastUiPosition.left  ? -mRight : mLeft);\r\n      let top = ui.position.top + (ui.position.top > node._lastUiPosition.top  ? -mBottom : mTop);\r\n      p.x = Math.round(left / cellWidth);\r\n      p.y = Math.round(top / cellHeight);\r\n\r\n      // @ts-ignore// if we're at the bottom hitting something else, grow the grid so cursor doesn't leave when trying to place below others\r\n      let prev = this._extraDragRow;\r\n      if (this.engine.collide(node, p)) {\r\n        let row = this.getRow();\r\n        let extra = Math.max(0, (p.y + node.h) - row);\r\n        if (this.opts.maxRow && row + extra > this.opts.maxRow) {\r\n          extra = Math.max(0, this.opts.maxRow - row);\r\n        }// @ts-ignore\r\n        this._extraDragRow = extra;// @ts-ignore\r\n      } else this._extraDragRow = 0;// @ts-ignore\r\n      if (this._extraDragRow !== prev) this._updateContainerHeight();\r\n\r\n      if (node.x === p.x && node.y === p.y) return; // skip same\r\n      // DON'T skip one we tried as we might have failed because of coverage <50% before\r\n      // if (node._lastTried && node._lastTried.x === x && node._lastTried.y === y) return;\r\n    } else if (event.type === 'resize')  {\r\n      if (p.x < 0) return;\r\n      // Scrolling page if needed\r\n      Utils.updateScrollResize(event, el, cellHeight);\r\n\r\n      // get new size\r\n      p.w = Math.round((ui.size.width - mLeft) / cellWidth);\r\n      p.h = Math.round((ui.size.height - mTop) / cellHeight);\r\n      if (node.w === p.w && node.h === p.h) return;\r\n      if (node._lastTried && node._lastTried.w === p.w && node._lastTried.h === p.h) return; // skip one we tried (but failed)\r\n\r\n      // if we size on left/top side this might move us, so get possible new position as well\r\n      let left = ui.position.left + mLeft;\r\n      let top = ui.position.top + mTop;\r\n      p.x = Math.round(left / cellWidth);\r\n      p.y = Math.round(top / cellHeight);\r\n\r\n      resizing = true;\r\n    }\r\n\r\n    node._event = event;\r\n    node._lastTried = p; // set as last tried (will nuke if we go there)\r\n    let rect: GridStackPosition = { // screen pix of the dragged box\r\n      x: ui.position.left + mLeft,\r\n      y: ui.position.top + mTop,\r\n      w: (ui.size ? ui.size.width : node.w * cellWidth) - mLeft - mRight,\r\n      h: (ui.size ? ui.size.height : node.h * cellHeight) - mTop - mBottom\r\n    };\r\n    if (this.engine.moveNodeCheck(node, {...p, cellWidth, cellHeight, rect, resizing})) {\r\n      node._lastUiPosition = ui.position;\r\n      this.engine.cacheRects(cellWidth, cellHeight, mTop, mRight, mBottom, mLeft);\r\n      delete node._skipDown;\r\n      if (resizing && node.subGrid) { (node.subGrid as GridStack).onParentResize(); }// @ts-ignore\r\n      this._extraDragRow = 0;// @ts-ignore\r\n      this._updateContainerHeight();\r\n\r\n      let target = event.target as GridItemHTMLElement;// @ts-ignore\r\n      this._writePosAttr(target, node);\r\n      if (this._gsEventHandler[event.type]) {\r\n        this._gsEventHandler[event.type](event, target);\r\n      }\r\n    }\r\n  }\r\n\r\n  /** @internal called when item leaving our area by either cursor dropout event\r\n   * or shape is outside our boundaries. remove it from us, and mark temporary if this was\r\n   * our item to start with else restore prev node values from prev grid it came from.\r\n   **/\r\n  protected _leave(el: GridItemHTMLElement, helper?: GridItemHTMLElement): void {\r\n    let node = el.gridstackNode;\r\n    if (!node) return;\r\n\r\n    dd.off(el, 'drag'); // no need to track while being outside\r\n\r\n    // this gets called when cursor leaves and shape is outside, so only do this once\r\n    if (node._temporaryRemoved) return;\r\n    node._temporaryRemoved = true;\r\n\r\n    this.engine.removeNode(node); // remove placeholder as well, otherwise it's a sign node is not in our list, which is a bigger issue\r\n    node.el = node._isExternal && helper ? helper : el; // point back to real item being dragged\r\n\r\n    if (this.opts.removable === true) { // boolean vs a class string\r\n      // item leaving us and we are supposed to remove on leave (no need to drag onto trash) mark it so\r\n      this._itemRemoving(el, true);\r\n    }\r\n\r\n    // finally if item originally came from another grid, but left us, restore things back to prev info\r\n    if (el._gridstackNodeOrig) {\r\n      // console.log('leave delete _gridstackNodeOrig') // TEST\r\n      el.gridstackNode = el._gridstackNodeOrig;\r\n      delete el._gridstackNodeOrig;\r\n    } else if (node._isExternal) {\r\n      // item came from outside (like a toolbar) so nuke any node info\r\n      delete node.el;\r\n      delete el.gridstackNode;\r\n      // and restore all nodes back to original\r\n      this.engine.restoreInitial();\r\n    }\r\n  }\r\n\r\n  // legacy method removed\r\n  public commit(): GridStack { obsolete(this, this.batchUpdate(false), 'commit', 'batchUpdate', '5.2'); return this; }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}