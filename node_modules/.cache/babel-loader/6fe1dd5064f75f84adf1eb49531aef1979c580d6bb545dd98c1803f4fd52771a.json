{"ast":null,"code":"\"use strict\";\n\n/**\r\n * dd-draggable.ts 7.2.3\r\n * Copyright (c) 2021-2022 Alain Dumesny - see GridStack root license\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DDDraggable = void 0;\nconst dd_manager_1 = require(\"./dd-manager\");\nconst utils_1 = require(\"./utils\");\nconst dd_base_impl_1 = require(\"./dd-base-impl\");\nconst dd_touch_1 = require(\"./dd-touch\");\n// let count = 0; // TEST\nclass DDDraggable extends dd_base_impl_1.DDBaseImplement {\n  constructor(el) {\n    let option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    this.el = el;\n    this.option = option;\n    // get the element that is actually supposed to be dragged by\n    let className = option.handle.substring(1);\n    this.dragEl = el.classList.contains(className) ? el : el.querySelector(option.handle) || el;\n    // create var event binding so we can easily remove and still look like TS methods (unlike anonymous functions)\n    this._mouseDown = this._mouseDown.bind(this);\n    this._mouseMove = this._mouseMove.bind(this);\n    this._mouseUp = this._mouseUp.bind(this);\n    this.enable();\n  }\n  on(event, callback) {\n    super.on(event, callback);\n  }\n  off(event) {\n    super.off(event);\n  }\n  enable() {\n    if (this.disabled === false) return;\n    super.enable();\n    this.dragEl.addEventListener('mousedown', this._mouseDown);\n    if (dd_touch_1.isTouch) {\n      this.dragEl.addEventListener('touchstart', dd_touch_1.touchstart);\n      this.dragEl.addEventListener('pointerdown', dd_touch_1.pointerdown);\n      // this.dragEl.style.touchAction = 'none'; // not needed unlike pointerdown doc comment\n    }\n\n    this.el.classList.remove('ui-draggable-disabled');\n    this.el.classList.add('ui-draggable');\n  }\n  disable() {\n    let forDestroy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.disabled === true) return;\n    super.disable();\n    this.dragEl.removeEventListener('mousedown', this._mouseDown);\n    if (dd_touch_1.isTouch) {\n      this.dragEl.removeEventListener('touchstart', dd_touch_1.touchstart);\n      this.dragEl.removeEventListener('pointerdown', dd_touch_1.pointerdown);\n    }\n    this.el.classList.remove('ui-draggable');\n    if (!forDestroy) this.el.classList.add('ui-draggable-disabled');\n  }\n  destroy() {\n    if (this.dragTimeout) window.clearTimeout(this.dragTimeout);\n    delete this.dragTimeout;\n    if (this.dragging) this._mouseUp(this.mouseDownEvent);\n    this.disable(true);\n    delete this.el;\n    delete this.helper;\n    delete this.option;\n    super.destroy();\n  }\n  updateOption(opts) {\n    Object.keys(opts).forEach(key => this.option[key] = opts[key]);\n    return this;\n  }\n  /** @internal call when mouse goes down before a dragstart happens */\n  _mouseDown(e) {\n    // don't let more than one widget handle mouseStart\n    if (dd_manager_1.DDManager.mouseHandled) return;\n    if (e.button !== 0) return true; // only left click\n    // make sure we are not clicking on known object that handles mouseDown (TODO: make this extensible ?) #2054\n    const skipMouseDown = ['input', 'textarea', 'button', 'select', 'option'];\n    const name = e.target.nodeName.toLowerCase();\n    if (skipMouseDown.find(skip => skip === name)) return true;\n    // also check for content editable\n    if (e.target.closest('[contenteditable=\"true\"]')) return true;\n    // make sure we are clicking on a drag handle or child of it...\n    // Note: we don't need to check that's handle is an immediate child, as mouseHandled will prevent parents from also handling it (lowest wins)\n    //\n    // REMOVE: why would we get the event if it wasn't for us or child ?\n    // let className = this.option.handle.substring(1);\n    // let el = e.target as HTMLElement;\n    // while (el && !el.classList.contains(className)) { el = el.parentElement; }\n    // if (!el) return;\n    this.mouseDownEvent = e;\n    delete this.dragging;\n    delete dd_manager_1.DDManager.dragElement;\n    delete dd_manager_1.DDManager.dropElement;\n    // document handler so we can continue receiving moves as the item is 'fixed' position, and capture=true so WE get a first crack\n    document.addEventListener('mousemove', this._mouseMove, true); // true=capture, not bubble\n    document.addEventListener('mouseup', this._mouseUp, true);\n    if (dd_touch_1.isTouch) {\n      this.dragEl.addEventListener('touchmove', dd_touch_1.touchmove);\n      this.dragEl.addEventListener('touchend', dd_touch_1.touchend);\n    }\n    e.preventDefault();\n    // preventDefault() prevents blur event which occurs just after mousedown event.\n    // if an editable content has focus, then blur must be call\n    if (document.activeElement) document.activeElement.blur();\n    dd_manager_1.DDManager.mouseHandled = true;\n    return true;\n  }\n  /** @internal method to call actual drag event */\n  _callDrag(e) {\n    if (!this.dragging) return;\n    const ev = utils_1.Utils.initEvent(e, {\n      target: this.el,\n      type: 'drag'\n    });\n    if (this.option.drag) {\n      this.option.drag(ev, this.ui());\n    }\n    this.triggerEvent('drag', ev);\n  }\n  /** @internal called when the main page (after successful mousedown) receives a move event to drag the item around the screen */\n  _mouseMove(e) {\n    var _a;\n    // console.log(`${count++} move ${e.x},${e.y}`)\n    let s = this.mouseDownEvent;\n    if (this.dragging) {\n      this._dragFollow(e);\n      // delay actual grid handling drag until we pause for a while if set\n      if (dd_manager_1.DDManager.pauseDrag) {\n        const pause = Number.isInteger(dd_manager_1.DDManager.pauseDrag) ? dd_manager_1.DDManager.pauseDrag : 100;\n        if (this.dragTimeout) window.clearTimeout(this.dragTimeout);\n        this.dragTimeout = window.setTimeout(() => this._callDrag(e), pause);\n      } else {\n        this._callDrag(e);\n      }\n    } else if (Math.abs(e.x - s.x) + Math.abs(e.y - s.y) > 3) {\n      /**\r\n       * don't start unless we've moved at least 3 pixels\r\n       */\n      this.dragging = true;\n      dd_manager_1.DDManager.dragElement = this;\n      // if we're dragging an actual grid item, set the current drop as the grid (to detect enter/leave)\n      let grid = (_a = this.el.gridstackNode) === null || _a === void 0 ? void 0 : _a.grid;\n      if (grid) {\n        dd_manager_1.DDManager.dropElement = grid.el.ddElement.ddDroppable;\n      } else {\n        delete dd_manager_1.DDManager.dropElement;\n      }\n      this.helper = this._createHelper(e);\n      this._setupHelperContainmentStyle();\n      this.dragOffset = this._getDragOffset(e, this.el, this.helperContainment);\n      const ev = utils_1.Utils.initEvent(e, {\n        target: this.el,\n        type: 'dragstart'\n      });\n      this._setupHelperStyle(e);\n      if (this.option.start) {\n        this.option.start(ev, this.ui());\n      }\n      this.triggerEvent('dragstart', ev);\n    }\n    e.preventDefault(); // needed otherwise we get text sweep text selection as we drag around\n    return true;\n  }\n  /** @internal call when the mouse gets released to drop the item at current location */\n  _mouseUp(e) {\n    var _a;\n    document.removeEventListener('mousemove', this._mouseMove, true);\n    document.removeEventListener('mouseup', this._mouseUp, true);\n    if (dd_touch_1.isTouch) {\n      this.dragEl.removeEventListener('touchmove', dd_touch_1.touchmove, true);\n      this.dragEl.removeEventListener('touchend', dd_touch_1.touchend, true);\n    }\n    if (this.dragging) {\n      delete this.dragging;\n      // reset the drop target if dragging over ourself (already parented, just moving during stop callback below)\n      if (((_a = dd_manager_1.DDManager.dropElement) === null || _a === void 0 ? void 0 : _a.el) === this.el.parentElement) {\n        delete dd_manager_1.DDManager.dropElement;\n      }\n      this.helperContainment.style.position = this.parentOriginStylePosition || null;\n      if (this.helper === this.el) {\n        this._removeHelperStyle();\n      } else {\n        this.helper.remove();\n      }\n      const ev = utils_1.Utils.initEvent(e, {\n        target: this.el,\n        type: 'dragstop'\n      });\n      if (this.option.stop) {\n        this.option.stop(ev); // NOTE: destroy() will be called when removing item, so expect NULL ptr after!\n      }\n\n      this.triggerEvent('dragstop', ev);\n      // call the droppable method to receive the item\n      if (dd_manager_1.DDManager.dropElement) {\n        dd_manager_1.DDManager.dropElement.drop(e);\n      }\n    }\n    delete this.helper;\n    delete this.mouseDownEvent;\n    delete dd_manager_1.DDManager.dragElement;\n    delete dd_manager_1.DDManager.dropElement;\n    delete dd_manager_1.DDManager.mouseHandled;\n    e.preventDefault();\n  }\n  /** @internal create a clone copy (or user defined method) of the original drag item if set */\n  _createHelper(event) {\n    let helper = this.el;\n    if (typeof this.option.helper === 'function') {\n      helper = this.option.helper(event);\n    } else if (this.option.helper === 'clone') {\n      helper = utils_1.Utils.cloneNode(this.el);\n    }\n    if (!document.body.contains(helper)) {\n      utils_1.Utils.appendTo(helper, this.option.appendTo === 'parent' ? this.el.parentNode : this.option.appendTo);\n    }\n    if (helper === this.el) {\n      this.dragElementOriginStyle = DDDraggable.originStyleProp.map(prop => this.el.style[prop]);\n    }\n    return helper;\n  }\n  /** @internal set the fix position of the dragged item */\n  _setupHelperStyle(e) {\n    this.helper.classList.add('ui-draggable-dragging');\n    // TODO: set all at once with style.cssText += ... ? https://stackoverflow.com/questions/3968593\n    const style = this.helper.style;\n    style.pointerEvents = 'none'; // needed for over items to get enter/leave\n    // style.cursor = 'move'; //  TODO: can't set with pointerEvents=none ! (done in CSS as well)\n    style['min-width'] = 0; // since we no longer relative to our parent and we don't resize anyway (normally 100/#column %)\n    style.width = this.dragOffset.width + 'px';\n    style.height = this.dragOffset.height + 'px';\n    style.willChange = 'left, top';\n    style.position = 'fixed'; // let us drag between grids by not clipping as parent .grid-stack is position: 'relative'\n    this._dragFollow(e); // now position it\n    style.transition = 'none'; // show up instantly\n    setTimeout(() => {\n      if (this.helper) {\n        style.transition = null; // recover animation\n      }\n    }, 0);\n    return this;\n  }\n  /** @internal restore back the original style before dragging */\n  _removeHelperStyle() {\n    var _a;\n    this.helper.classList.remove('ui-draggable-dragging');\n    let node = (_a = this.helper) === null || _a === void 0 ? void 0 : _a.gridstackNode;\n    // don't bother restoring styles if we're gonna remove anyway...\n    if (!(node === null || node === void 0 ? void 0 : node._isAboutToRemove) && this.dragElementOriginStyle) {\n      let helper = this.helper;\n      // don't animate, otherwise we animate offseted when switching back to 'absolute' from 'fixed'.\n      // TODO: this also removes resizing animation which doesn't have this issue, but others.\n      // Ideally both would animate ('move' would immediately restore 'absolute' and adjust coordinate to match,\n      // then trigger a delay (repaint) to restore to final dest with animate) but then we need to make sure 'resizestop'\n      // is called AFTER 'transitionend' event is received (see https://github.com/gridstack/gridstack.js/issues/2033)\n      let transition = this.dragElementOriginStyle['transition'] || null;\n      helper.style.transition = this.dragElementOriginStyle['transition'] = 'none'; // can't be NULL #1973\n      DDDraggable.originStyleProp.forEach(prop => helper.style[prop] = this.dragElementOriginStyle[prop] || null);\n      setTimeout(() => helper.style.transition = transition, 50); // recover animation from saved vars after a pause (0 isn't enough #1973)\n    }\n\n    delete this.dragElementOriginStyle;\n    return this;\n  }\n  /** @internal updates the top/left position to follow the mouse */\n  _dragFollow(e) {\n    let containmentRect = {\n      left: 0,\n      top: 0\n    };\n    // if (this.helper.style.position === 'absolute') { // we use 'fixed'\n    //   const { left, top } = this.helperContainment.getBoundingClientRect();\n    //   containmentRect = { left, top };\n    // }\n    const style = this.helper.style;\n    const offset = this.dragOffset;\n    style.left = e.clientX + offset.offsetLeft - containmentRect.left + 'px';\n    style.top = e.clientY + offset.offsetTop - containmentRect.top + 'px';\n  }\n  /** @internal */\n  _setupHelperContainmentStyle() {\n    this.helperContainment = this.helper.parentElement;\n    if (this.helper.style.position !== 'fixed') {\n      this.parentOriginStylePosition = this.helperContainment.style.position;\n      if (window.getComputedStyle(this.helperContainment).position.match(/static/)) {\n        this.helperContainment.style.position = 'relative';\n      }\n    }\n    return this;\n  }\n  /** @internal */\n  _getDragOffset(event, el, parent) {\n    // in case ancestor has transform/perspective css properties that change the viewpoint\n    let xformOffsetX = 0;\n    let xformOffsetY = 0;\n    if (parent) {\n      const testEl = document.createElement('div');\n      utils_1.Utils.addElStyles(testEl, {\n        opacity: '0',\n        position: 'fixed',\n        top: 0 + 'px',\n        left: 0 + 'px',\n        width: '1px',\n        height: '1px',\n        zIndex: '-999999'\n      });\n      parent.appendChild(testEl);\n      const testElPosition = testEl.getBoundingClientRect();\n      parent.removeChild(testEl);\n      xformOffsetX = testElPosition.left;\n      xformOffsetY = testElPosition.top;\n      // TODO: scale ?\n    }\n\n    const targetOffset = el.getBoundingClientRect();\n    return {\n      left: targetOffset.left,\n      top: targetOffset.top,\n      offsetLeft: -event.clientX + targetOffset.left - xformOffsetX,\n      offsetTop: -event.clientY + targetOffset.top - xformOffsetY,\n      width: targetOffset.width,\n      height: targetOffset.height\n    };\n  }\n  /** @internal TODO: set to public as called by DDDroppable! */\n  ui() {\n    const containmentEl = this.el.parentElement;\n    const containmentRect = containmentEl.getBoundingClientRect();\n    const offset = this.helper.getBoundingClientRect();\n    return {\n      position: {\n        top: offset.top - containmentRect.top,\n        left: offset.left - containmentRect.left\n      }\n      /* not used by GridStack for now...\r\n      helper: [this.helper], //The object arr representing the helper that's being dragged.\r\n      offset: { top: offset.top, left: offset.left } // Current offset position of the helper as { top, left } object.\r\n      */\n    };\n  }\n}\n\nexports.DDDraggable = DDDraggable;\n/** @internal properties we change during dragging, and restore back */\nDDDraggable.originStyleProp = ['transition', 'pointerEvents', 'position', 'left', 'top', 'minWidth', 'willChange'];","map":{"version":3,"names":["dd_manager_1","require","utils_1","dd_base_impl_1","dd_touch_1","DDDraggable","DDBaseImplement","constructor","el","option","arguments","length","undefined","className","handle","substring","dragEl","classList","contains","querySelector","_mouseDown","bind","_mouseMove","_mouseUp","enable","on","event","callback","off","disabled","addEventListener","isTouch","touchstart","pointerdown","remove","add","disable","forDestroy","removeEventListener","destroy","dragTimeout","window","clearTimeout","dragging","mouseDownEvent","helper","updateOption","opts","Object","keys","forEach","key","e","DDManager","mouseHandled","button","skipMouseDown","name","target","nodeName","toLowerCase","find","skip","closest","dragElement","dropElement","document","touchmove","touchend","preventDefault","activeElement","blur","_callDrag","ev","Utils","initEvent","type","drag","ui","triggerEvent","s","_dragFollow","pauseDrag","pause","Number","isInteger","setTimeout","Math","abs","x","y","grid","_a","gridstackNode","ddElement","ddDroppable","_createHelper","_setupHelperContainmentStyle","dragOffset","_getDragOffset","helperContainment","_setupHelperStyle","start","parentElement","style","position","parentOriginStylePosition","_removeHelperStyle","stop","drop","cloneNode","body","appendTo","parentNode","dragElementOriginStyle","originStyleProp","map","prop","pointerEvents","width","height","willChange","transition","node","_isAboutToRemove","containmentRect","left","top","offset","clientX","offsetLeft","clientY","offsetTop","getComputedStyle","match","parent","xformOffsetX","xformOffsetY","testEl","createElement","addElStyles","opacity","zIndex","appendChild","testElPosition","getBoundingClientRect","removeChild","targetOffset","containmentEl","exports"],"sources":["/home/catarina.santos/litegride/node_modules/gridstack/src/dd-draggable.ts"],"sourcesContent":["/**\n * dd-draggable.ts 7.2.3\n * Copyright (c) 2021-2022 Alain Dumesny - see GridStack root license\n */\n\nimport { DDManager } from './dd-manager';\nimport { Utils } from './utils';\nimport { DDBaseImplement, HTMLElementExtendOpt } from './dd-base-impl';\nimport { GridItemHTMLElement, DDUIData } from './types';\nimport { DDElementHost } from './dd-element';\nimport { isTouch, touchend, touchmove, touchstart, pointerdown } from './dd-touch';\n\n// TODO: merge with DDDragOpt ?\nexport interface DDDraggableOpt {\n  appendTo?: string | HTMLElement;\n  handle?: string;\n  helper?: string | HTMLElement | ((event: Event) => HTMLElement);\n  // containment?: string | HTMLElement; // TODO: not implemented yet\n  // revert?: string | boolean | unknown; // TODO: not implemented yet\n  // scroll?: boolean; // native support by HTML5 drag drop, can't be switch to off actually\n  start?: (event: Event, ui: DDUIData) => void;\n  stop?: (event: Event) => void;\n  drag?: (event: Event, ui: DDUIData) => void;\n}\n\ninterface DragOffset {\n  left: number;\n  top: number;\n  width: number;\n  height: number;\n  offsetLeft: number;\n  offsetTop: number;\n}\n\ntype DDDragEvent = 'drag' | 'dragstart' | 'dragstop';\n\n// let count = 0; // TEST\n\nexport class DDDraggable extends DDBaseImplement implements HTMLElementExtendOpt<DDDraggableOpt> {\n  public el: HTMLElement;\n  public option: DDDraggableOpt;\n  public helper: HTMLElement; // used by GridStackDDNative\n\n  /** @internal */\n  protected mouseDownEvent: MouseEvent;\n  /** @internal */\n  protected dragOffset: DragOffset;\n  /** @internal */\n  protected dragElementOriginStyle: Array<string>;\n  /** @internal */\n  protected dragEl: HTMLElement;\n  /** @internal true while we are dragging an item around */\n  protected dragging: boolean;\n  /** @internal */\n  protected parentOriginStylePosition: string;\n  /** @internal */\n  protected helperContainment: HTMLElement;\n  /** @internal properties we change during dragging, and restore back */\n  protected static originStyleProp = ['transition', 'pointerEvents', 'position', 'left', 'top', 'minWidth', 'willChange'];\n  /** @internal pause before we call the actual drag hit collision code */\n  protected dragTimeout: number;\n\n  constructor(el: HTMLElement, option: DDDraggableOpt = {}) {\n    super();\n    this.el = el;\n    this.option = option;\n    // get the element that is actually supposed to be dragged by\n    let className = option.handle.substring(1);\n    this.dragEl = el.classList.contains(className) ? el : el.querySelector(option.handle) || el;\n    // create var event binding so we can easily remove and still look like TS methods (unlike anonymous functions)\n    this._mouseDown = this._mouseDown.bind(this);\n    this._mouseMove = this._mouseMove.bind(this);\n    this._mouseUp = this._mouseUp.bind(this);\n    this.enable();\n  }\n\n  public on(event: DDDragEvent, callback: (event: DragEvent) => void): void {\n    super.on(event, callback);\n  }\n\n  public off(event: DDDragEvent): void {\n    super.off(event);\n  }\n\n  public enable(): void {\n    if (this.disabled === false) return;\n    super.enable();\n    this.dragEl.addEventListener('mousedown', this._mouseDown);\n    if (isTouch) {\n      this.dragEl.addEventListener('touchstart', touchstart);\n      this.dragEl.addEventListener('pointerdown', pointerdown);\n      // this.dragEl.style.touchAction = 'none'; // not needed unlike pointerdown doc comment\n    }\n    this.el.classList.remove('ui-draggable-disabled');\n    this.el.classList.add('ui-draggable');\n  }\n\n  public disable(forDestroy = false): void {\n    if (this.disabled === true) return;\n    super.disable();\n    this.dragEl.removeEventListener('mousedown', this._mouseDown);\n    if (isTouch) {\n      this.dragEl.removeEventListener('touchstart', touchstart);\n      this.dragEl.removeEventListener('pointerdown', pointerdown);\n    }\n    this.el.classList.remove('ui-draggable');\n    if (!forDestroy) this.el.classList.add('ui-draggable-disabled');\n  }\n\n  public destroy(): void {\n    if (this.dragTimeout) window.clearTimeout(this.dragTimeout);\n    delete this.dragTimeout;\n    if (this.dragging) this._mouseUp(this.mouseDownEvent);\n    this.disable(true);\n    delete this.el;\n    delete this.helper;\n    delete this.option;\n    super.destroy();\n  }\n\n  public updateOption(opts: DDDraggableOpt): DDDraggable {\n    Object.keys(opts).forEach(key => this.option[key] = opts[key]);\n    return this;\n  }\n\n  /** @internal call when mouse goes down before a dragstart happens */\n  protected _mouseDown(e: MouseEvent): boolean {\n    // don't let more than one widget handle mouseStart\n    if (DDManager.mouseHandled) return;\n    if (e.button !== 0) return true; // only left click\n\n    // make sure we are not clicking on known object that handles mouseDown (TODO: make this extensible ?) #2054\n    const skipMouseDown = ['input', 'textarea', 'button', 'select', 'option'];\n    const name = (e.target as HTMLElement).nodeName.toLowerCase();\n    if (skipMouseDown.find(skip => skip === name)) return true;\n    // also check for content editable\n    if ((e.target as HTMLElement).closest('[contenteditable=\"true\"]')) return true;\n\n    // make sure we are clicking on a drag handle or child of it...\n    // Note: we don't need to check that's handle is an immediate child, as mouseHandled will prevent parents from also handling it (lowest wins)\n    //\n    // REMOVE: why would we get the event if it wasn't for us or child ?\n    // let className = this.option.handle.substring(1);\n    // let el = e.target as HTMLElement;\n    // while (el && !el.classList.contains(className)) { el = el.parentElement; }\n    // if (!el) return;\n    this.mouseDownEvent = e;\n    delete this.dragging;\n    delete DDManager.dragElement;\n    delete DDManager.dropElement;\n    // document handler so we can continue receiving moves as the item is 'fixed' position, and capture=true so WE get a first crack\n    document.addEventListener('mousemove', this._mouseMove, true); // true=capture, not bubble\n    document.addEventListener('mouseup', this._mouseUp, true);\n    if (isTouch) {\n      this.dragEl.addEventListener('touchmove', touchmove);\n      this.dragEl.addEventListener('touchend', touchend);\n    }\n\n    e.preventDefault();\n    // preventDefault() prevents blur event which occurs just after mousedown event.\n    // if an editable content has focus, then blur must be call\n    if(document.activeElement) (document.activeElement  as HTMLElement).blur();\n\n    DDManager.mouseHandled = true;\n    return true;\n  }\n\n  /** @internal method to call actual drag event */\n  protected _callDrag(e: DragEvent): void {\n    if (!this.dragging) return;\n    const ev = Utils.initEvent<DragEvent>(e, { target: this.el, type: 'drag' });\n    if (this.option.drag) {\n      this.option.drag(ev, this.ui());\n    }\n    this.triggerEvent('drag', ev);\n  }\n\n  /** @internal called when the main page (after successful mousedown) receives a move event to drag the item around the screen */\n  protected _mouseMove(e: DragEvent): boolean {\n    // console.log(`${count++} move ${e.x},${e.y}`)\n    let s = this.mouseDownEvent;\n\n    if (this.dragging) {\n      this._dragFollow(e);\n      // delay actual grid handling drag until we pause for a while if set\n      if (DDManager.pauseDrag) {\n        const pause = Number.isInteger(DDManager.pauseDrag) ? DDManager.pauseDrag as number : 100;\n        if (this.dragTimeout) window.clearTimeout(this.dragTimeout);\n        this.dragTimeout = window.setTimeout(() => this._callDrag(e), pause);\n      } else {\n        this._callDrag(e);\n      }\n    } else if (Math.abs(e.x - s.x) + Math.abs(e.y - s.y) > 3) {\n      /**\n       * don't start unless we've moved at least 3 pixels\n       */\n      this.dragging = true;\n      DDManager.dragElement = this;\n      // if we're dragging an actual grid item, set the current drop as the grid (to detect enter/leave)\n      let grid = (this.el as GridItemHTMLElement).gridstackNode?.grid;\n      if (grid) {\n        DDManager.dropElement = (grid.el as DDElementHost).ddElement.ddDroppable;\n      } else {\n        delete DDManager.dropElement;\n      }\n      this.helper = this._createHelper(e);\n      this._setupHelperContainmentStyle();\n      this.dragOffset = this._getDragOffset(e, this.el, this.helperContainment);\n      const ev = Utils.initEvent<DragEvent>(e, { target: this.el, type: 'dragstart' });\n\n      this._setupHelperStyle(e);\n      if (this.option.start) {\n        this.option.start(ev, this.ui());\n      }\n      this.triggerEvent('dragstart', ev);\n    }\n    e.preventDefault(); // needed otherwise we get text sweep text selection as we drag around\n    return true;\n  }\n\n  /** @internal call when the mouse gets released to drop the item at current location */\n  protected _mouseUp(e: MouseEvent): void {\n    document.removeEventListener('mousemove', this._mouseMove, true);\n    document.removeEventListener('mouseup', this._mouseUp, true);\n    if (isTouch) {\n      this.dragEl.removeEventListener('touchmove', touchmove, true);\n      this.dragEl.removeEventListener('touchend', touchend, true);\n    }\n    if (this.dragging) {\n      delete this.dragging;\n\n      // reset the drop target if dragging over ourself (already parented, just moving during stop callback below)\n      if (DDManager.dropElement?.el === this.el.parentElement) {\n        delete DDManager.dropElement;\n      }\n\n      this.helperContainment.style.position = this.parentOriginStylePosition || null;\n      if (this.helper === this.el) {\n        this._removeHelperStyle();\n      } else {\n        this.helper.remove();\n      }\n      const ev = Utils.initEvent<DragEvent>(e, { target: this.el, type: 'dragstop' });\n      if (this.option.stop) {\n        this.option.stop(ev); // NOTE: destroy() will be called when removing item, so expect NULL ptr after!\n      }\n      this.triggerEvent('dragstop', ev);\n\n      // call the droppable method to receive the item\n      if (DDManager.dropElement) {\n        DDManager.dropElement.drop(e);\n      }\n    }\n    delete this.helper;\n    delete this.mouseDownEvent;\n    delete DDManager.dragElement;\n    delete DDManager.dropElement;\n    delete DDManager.mouseHandled;\n    e.preventDefault();\n  }\n\n  /** @internal create a clone copy (or user defined method) of the original drag item if set */\n  protected _createHelper(event: DragEvent): HTMLElement {\n    let helper = this.el;\n    if (typeof this.option.helper === 'function') {\n      helper = this.option.helper(event);\n    } else if (this.option.helper === 'clone') {\n      helper = Utils.cloneNode(this.el);\n    }\n    if (!document.body.contains(helper)) {\n      Utils.appendTo(helper, this.option.appendTo === 'parent' ? this.el.parentNode : this.option.appendTo);\n    }\n    if (helper === this.el) {\n      this.dragElementOriginStyle = DDDraggable.originStyleProp.map(prop => this.el.style[prop]);\n    }\n    return helper;\n  }\n\n  /** @internal set the fix position of the dragged item */\n  protected _setupHelperStyle(e: DragEvent): DDDraggable {\n    this.helper.classList.add('ui-draggable-dragging');\n    // TODO: set all at once with style.cssText += ... ? https://stackoverflow.com/questions/3968593\n    const style = this.helper.style;\n    style.pointerEvents = 'none'; // needed for over items to get enter/leave\n    // style.cursor = 'move'; //  TODO: can't set with pointerEvents=none ! (done in CSS as well)\n    style['min-width'] = 0; // since we no longer relative to our parent and we don't resize anyway (normally 100/#column %)\n    style.width = this.dragOffset.width + 'px';\n    style.height = this.dragOffset.height + 'px';\n    style.willChange = 'left, top';\n    style.position = 'fixed'; // let us drag between grids by not clipping as parent .grid-stack is position: 'relative'\n    this._dragFollow(e); // now position it\n    style.transition = 'none'; // show up instantly\n    setTimeout(() => {\n      if (this.helper) {\n        style.transition = null; // recover animation\n      }\n    }, 0);\n    return this;\n  }\n\n  /** @internal restore back the original style before dragging */\n  protected _removeHelperStyle(): DDDraggable {\n    this.helper.classList.remove('ui-draggable-dragging');\n    let node = (this.helper as GridItemHTMLElement)?.gridstackNode;\n    // don't bother restoring styles if we're gonna remove anyway...\n    if (!node?._isAboutToRemove && this.dragElementOriginStyle) {\n      let helper = this.helper;\n      // don't animate, otherwise we animate offseted when switching back to 'absolute' from 'fixed'.\n      // TODO: this also removes resizing animation which doesn't have this issue, but others.\n      // Ideally both would animate ('move' would immediately restore 'absolute' and adjust coordinate to match,\n      // then trigger a delay (repaint) to restore to final dest with animate) but then we need to make sure 'resizestop'\n      // is called AFTER 'transitionend' event is received (see https://github.com/gridstack/gridstack.js/issues/2033)\n      let transition = this.dragElementOriginStyle['transition'] || null;\n      helper.style.transition = this.dragElementOriginStyle['transition'] = 'none'; // can't be NULL #1973\n      DDDraggable.originStyleProp.forEach(prop => helper.style[prop] = this.dragElementOriginStyle[prop] || null);\n      setTimeout(() => helper.style.transition = transition, 50); // recover animation from saved vars after a pause (0 isn't enough #1973)\n    }\n    delete this.dragElementOriginStyle;\n    return this;\n  }\n\n  /** @internal updates the top/left position to follow the mouse */\n  protected _dragFollow(e: DragEvent): void {\n    let containmentRect = { left: 0, top: 0 };\n    // if (this.helper.style.position === 'absolute') { // we use 'fixed'\n    //   const { left, top } = this.helperContainment.getBoundingClientRect();\n    //   containmentRect = { left, top };\n    // }\n    const style = this.helper.style;\n    const offset = this.dragOffset;\n    style.left = e.clientX + offset.offsetLeft - containmentRect.left + 'px';\n    style.top = e.clientY + offset.offsetTop - containmentRect.top + 'px';\n  }\n\n  /** @internal */\n  protected _setupHelperContainmentStyle(): DDDraggable {\n    this.helperContainment = this.helper.parentElement;\n    if (this.helper.style.position !== 'fixed') {\n      this.parentOriginStylePosition = this.helperContainment.style.position;\n      if (window.getComputedStyle(this.helperContainment).position.match(/static/)) {\n        this.helperContainment.style.position = 'relative';\n      }\n    }\n    return this;\n  }\n\n  /** @internal */\n  protected _getDragOffset(event: DragEvent, el: HTMLElement, parent: HTMLElement): DragOffset {\n\n    // in case ancestor has transform/perspective css properties that change the viewpoint\n    let xformOffsetX = 0;\n    let xformOffsetY = 0;\n    if (parent) {\n      const testEl = document.createElement('div');\n      Utils.addElStyles(testEl, {\n        opacity: '0',\n        position: 'fixed',\n        top: 0 + 'px',\n        left: 0 + 'px',\n        width: '1px',\n        height: '1px',\n        zIndex: '-999999',\n      });\n      parent.appendChild(testEl);\n      const testElPosition = testEl.getBoundingClientRect();\n      parent.removeChild(testEl);\n      xformOffsetX = testElPosition.left;\n      xformOffsetY = testElPosition.top;\n      // TODO: scale ?\n    }\n\n    const targetOffset = el.getBoundingClientRect();\n    return {\n      left: targetOffset.left,\n      top: targetOffset.top,\n      offsetLeft: - event.clientX + targetOffset.left - xformOffsetX,\n      offsetTop: - event.clientY + targetOffset.top - xformOffsetY,\n      width: targetOffset.width,\n      height: targetOffset.height\n    };\n  }\n\n  /** @internal TODO: set to public as called by DDDroppable! */\n  public ui(): DDUIData {\n    const containmentEl = this.el.parentElement;\n    const containmentRect = containmentEl.getBoundingClientRect();\n    const offset = this.helper.getBoundingClientRect();\n    return {\n      position: { //Current CSS position of the helper as { top, left } object\n        top: offset.top - containmentRect.top,\n        left: offset.left - containmentRect.left\n      }\n      /* not used by GridStack for now...\n      helper: [this.helper], //The object arr representing the helper that's being dragged.\n      offset: { top: offset.top, left: offset.left } // Current offset position of the helper as { top, left } object.\n      */\n    };\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}